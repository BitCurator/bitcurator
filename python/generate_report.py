#!/usr/bin/python
# coding=UTF-8
# 
'''
File: bc_generate_report.py
A module for working with bulk_extractor

This module works with bulk_extractor and identify_filenames modules
and extracts the annotaed files  generated by the identify_filenames
module and generates a report.

Note-1: It uses the python-3 port of FPDF software from 
https://bitbucket.org/cyraxjoe/py3fpdf. So PYTHONPATH should include
the path to this directory.

Note-2: The following sequence is required to run this report:
1. Generate output feature files using Bulk Extractor
Ex: bulk_extractor 
    ~/Research/TestData/M57-Scenario/usbflashdrives/jo-work-usb-2009-12-11.aff 
    -o ~/Research/TestData/BEOutputs/jow-output

2. Generate the Text output from the fiwalk utility.
Ex: fiwalk -X /home/sunitha/Research/TestData/BEOutputs/jo-work-usb-fi.xml 
   -T /home/sunitha/Research/TestData/BEOutputs/jo-work-usb-fi_T 
    jo-work-usb-2009-12-11.aff
Ex2: fiwalk -f -X icharlie_F.xml -T icharlie_FT ~/Research/TestData/M57-Scenario/usbflashdrives/jo-work-usb-2009-12-11.aff 

3. Generate the annotated files from the identify_filenames utility
Ex: python3 identify_filenames.py --all --imagefile 
    ~/Research/TestData/M57-Scenario/usbflashdrives/jo-work-usb-2009-12-11.aff 
    ~/Research/TestData/BEOutputs/jow-output 
    ~/Research/TestData/BEOutputs/ident-jow-output
4. Run the identify_filenames again to generate the text and pdf reports.
    (this uses the annotated feature files created in step-3 and fiwalk output
     created in Step-2)
Ex: python3 identify_filenames.py --pdf_report 
    --fiwalk_txtfile ~/Research/TestData/BEOutputs/jo-work-usb-fi_T 
     ~/Research/TestData/BEOutputs/jow-output ident-jow-output
'''

__version__ = "1.3.0"

b'This module needs Python 2.7 or later.'
import zipfile,os,os.path,glob,codecs
##from fpdf import FPDF, HTMLMixin
from fpdf import *
#from html import HTMLMixin
import re
import os
import fnmatch
from collections import namedtuple
import numpy
import matplotlib
import matplotlib.pyplot as plt
import string
from matplotlib.backends.backend_pdf import PdfPages
from pylab import *
import datetime
import pylab as p

reportFileList = [None]*20
reportFiles = 0

def bc_addToReportFileList(pdf_file):
    reportFileList[PdfReport.reportFiles] = pdf_file
    # print("bc_addTpReportFileList: Creating PDF File: ", pdf_file, PdfReport.reportFiles)
    PdfReport.reportFiles += 1
    ## for i in range(0, PdfReport.reportFiles):
        ## print("D: reportList[i]:", i, reportFileList[i]) 

def bc_printReportFileList():
    print("The following Report Files are Generated: ")
    for i in range(0, PdfReport.reportFiles):
        print("%d)  %s" % (i+1, reportFileList[i])) 

def is_comment_line(line):
    if len(line)==0: return False
    if line[0:4]==b'\xef\xbb\xbf#': return True
    if line[0:1]=='\ufeff':
        line=line[1:]       # ignore unicode BOM
    try:
        if ord(line[0])==65279:
            line=line[1:]       # ignore unicode BOM
    except TypeError:
        pass
    if line[0:1]==b'#' or line[0:1]=='#':
        return True
    return False

def match_and_write(of, line, pattern, separator):
    if re.match(pattern,line):
        line1 = re.split(":", line.rstrip('\n'))
        ##print("match_and_write: DEBUG: LINE1: ", line1, line1[1])
        of.write(bytes(line1[1], 'UTF-8')) 
        if (separator):
            of.write(b";") 
        else:
            of.write(b"\n") 

def bc_analyze_zip_file(of, line):
    line1 = line.split("\t")
    ##for i  in range(0, len(line1)):
        ##print("DEBUG:", line1[i])

def bc_update_histo_list(list_item):
    # Walk through the list looking for the list_item.
    # If not found, add an item each to domain_list and histo_list.
    # These two lists have equal number of elements and each index
    # in the former has a corresponding number (number of occurances)
    # in the domain_histo_list. If the element is found in the big list 
    # (domain_list_all), then increment the corresponding histo_list

    if (len(PdfReport.domain_list) == 0):
        ##print("FIRST ITEM: Appending list_item to domain_list ", list_item)
        PdfReport.domain_list.append(list_item)
        PdfReport.domain_histo_list.append(1)
        return

    for j in range(0, len(PdfReport.domain_list)):
        ##print(" dl[] = ", j, PdfReport.domain_list[j], list_item) 
        if (PdfReport.domain_list[j] == list_item):
            # item exists in the domain_list. Increment
            # corresponding element in histo_list
            ##print(" They are the same. So incrementing h-list ")
            PdfReport.domain_histo_list[j] += 1
            break

    else:
        #print(" dl[NOW] = ", j, PdfReport.domain_list[j], list_item) 
        if (PdfReport.domain_list[j] != list_item):
            # Done traversing the domain_list. Add the new element
            # to both the domain and histogram lists.
            ##print("Appending list_item to domain_list ", list_item)
            PdfReport.domain_list.append(list_item)
            PdfReport.domain_histo_list.append(1)
            
    ##print("domain_list", PdfReport.domain_list)
    ##print("domain__histo_list", PdfReport.domain_histo_list)
    ##for k in range(0, len(PdfReport.domain_list)):
        ##of.write(bytes(PdfReport.domain_list_all[k], 'UTF-8')) 
        ##print(PdfReport.domain_list[k]) 
        ##print(PdfReport.domain_histo_list[k]) 
            

def bc_analyze_domain_file(of, line):

    line1 = line.split("\t")
    #print("STATICVAR : %d ", PdfReport.static_var)


    # Populate the array
    ##print("Appending to ALL file: ", line1[1])
    PdfReport.domain_list_all.append(line1[1])
    bc_update_histo_list(line1[1])

'''
        #of.write(bytes(PdfReport.domain_list_all, 'UTF-8')) 
        ## The following writes all the domains - kept just
        ## to test. Remove before cleanup.
        ##for j in range(0, len(PdfReport.domain_list_all)):
        ##of.write(bytes(PdfReport.domain_list_all[j], 'UTF-8')) 
'''
# Checks if the report has reached the end of page and if so, starts
# a new page. 
def bc_table_end_page(pdf, linenum, header, w):
    if ((linenum>=DirReport.max_entries_per_page) & 
        (linenum%DirReport.max_entries_per_page == 0)):
        ##print("Adding page", linenum)
        # Close the page
        pdf.cell(sum(w),0,'','T')
        pdf.add_page()
        for i in range(0,len(header)):
            pdf.cell(w[i],7,header[i],1,0,'C',1)
        pdf.ln()
    DirReport.page = pdf.page

def bc_analyze_lines(of, line, input_file):
    #if (input_file in "annotated_zip.txt"):
    if (fnmatch.fnmatch(input_file, '*annotated_zip.txt')):
        #print ("Analyzing ZIP file")
        bc_analyze_zip_file(of, line)
    elif (fnmatch.fnmatch(input_file, '*annotated_domain.txt')):
        ##print ("Analyzing DOMAIN file")
        bc_analyze_domain_file(of, line)

def bc_write_histo_outfile(of):

    of.write(b"\n\n")
    of.write(b"Domain ")
    of.write(b"\t\t\t ") 
    of.write(b"Frequency")
    of.write(b"\n")

    print("\n\n")
    print("Domain \t\t\t Frequency") 
    print("\n")
    print("LRN: ", len(PdfReport.domain_list))
    for k in range (0, len(PdfReport.domain_list)): 
        print(PdfReport.domain_list[k], 
                          PdfReport.domain_histo_list[k])
        ##print("\t\t\t") 
        ##print(PdfReport.domain_histo_list[k])
        of.write(bytes(PdfReport.domain_list[k], 'UTF-8'))
        of.write(b"\t\t\t") 

        of.write(bytes(str(PdfReport.domain_histo_list[k]), 'UTF-8'))
        #of.write(bytes(PdfReport.domain_histo_list[k], 'UTF-8'))
        of.write(b"\n")

        of.write(b"\n")

# Class PDF_BE to write the report to a PDF file.
# It uses the Bulk-Extractor output information as its input.
# It uses the python-3 port of FPDF software from 
# https://bitbucket.org/cyraxjoe/py3fpdf. 
class PDF_BE(FPDF):
        def header(this):
                # Logo
                this.image('FinalBitCuratorLogo-NoText.png',10,8,33)
                # Arial bold 15
                this.set_font('Arial','B',15)
                # Move to the right
                this.cell(80)
                # Title
                this.cell(70,10,'Bulk Extractor Report',1,0,'C')
                # Line break
                this.ln(20)

        # Page footer
        def footer(this):
                # Position at 1.5 cm from bottom
                this.set_y(-15)
                # Arial italic 8
                this.set_font('Arial','I',8)
                # Page number
                ##this.cell(0,10,'Page '+str(this.page())+'/{nb}',0,0,'C')
                this.cell(0,10,'Page '+str(this.page),0,0,'C')
        #
        # This function builds the table for reporting the information 
        # gathered from the feature files created by bulk-extractor
        #
        def make_table_be(self, header,filename):
                #self.set_fill_color(135,0,0)
                self.set_text_color(20)
                #self.set_draw_color(128,0,0)
                self.set_font('Times','B',10)
                self.underline = 1

                self.cell(0, 10, "Report of Overall Features", border=0, ln=1)
                self.underline = 0
                self.set_font('Times','I',8)
                self.cell(0,5, "FLTF:Total features located to files ", 
                                        border=0, ln=1)
                self.cell(0,5, "FIUF:Total features unallocated to files ", 
                                        border=0, ln=1)
                self.cell(0,5, "FICR:Total features in compressed regions ", 
                                        border=0, ln=1)

                #Colors, line width and bold font
                self.set_fill_color(135,0,0)
                self.set_text_color(255)
                self.set_draw_color(128,0,0)
                self.set_line_width(.3)
                self.set_font('','B')

                #Header (hardcoded columb width)
                w=[50,30,20,20,20]

                for i in range(0,len(header)):
                        self.cell(w[i],7,header[i],1,0,'C',1)
                self.ln()

                #Color and font restoration
                self.set_fill_color(224,235,255)
                self.set_text_color(0)
                self.set_font('')

                fill=0
                self.set_font('Times','',12)

                data=[]
                for line in open(filename):
                    data += [line[:-1].split(';')]

                for row in data:
                    self.cell(w[0],6,row[0],'LR',0,'L',fill)
                    self.cell(w[1],6,row[1],'LR',0,'L',fill)
                    self.cell(w[2],6,row[2],'LR',0,'R',fill)
                    self.cell(w[3],6,row[3],'LR',0,'R',fill)
                    self.cell(w[4],6,row[4],'LR',0,'R',fill)
                    self.ln()
                    fill=not fill

                #Closure line
                self.cell(sum(w),0,'','T')

        def bc_adjust_text(self, cell_text, cell_width):
            if len(cell_text) > cell_width:
                short_len = cell_width/2 - 5
                print("SSSSSSSSSHORTLEN:",len(cell_text), cell_width, short_len)
                text = cell_text[0:int(short_len)] + '...' + cell_text[-int(short_len):]
                return text
            return cell_text
           

        ##def bc_write_colomn(w[0],6,filename,'LR',0,'L',fill)
        def bc_write_column(self, w,h,cell_text, fill):
            text = self.bc_adjust_text(cell_text, w)
            self.cell(w,h,text,'LR',0,'L',fill)

        def make_table_feat(self, feature_file, header):
            self.set_text_color(1)
            self.set_font('Times','B',12)
            self.underline = 1
           
            fill=0

            self.cell(40, 7, 'Feature File: '+feature_file, border=0, ln=1)
            #self.set_font('Times','B',10)
            self.set_font('Times','',8)
            #self.cell(0, 10, "feature_file", border=0, ln=1)
            self.underline = 0
            #header = 'Feature File: ' + feature_file
            #print("Header: ", header)

            #self.cell(0, 10, header, 1)
            #if hdr:
                #return

            #Colors, line width and bold font
            ##self.set_fill_color(120,150,200)
            self.set_fill_color(224,235,255)
            ##self.set_text_color(10)
            self.set_text_color(0)
            self.set_draw_color(128,0,0)
            self.set_line_width(.3)
            ## self.set_font('','B')

            #Header (hardcoded column width)
            # Filename; position; feature
            w=[80,30,80]

            for i in range(0,len(header)):
                self.cell(w[i],7,header[i],1,0,'C',1)
            self.ln()

            data=[]
            linenum = 0
            for line in open(feature_file):
                if is_comment_line(line):
                    continue
                #if ((re.match("Total features",line) or ) :
                if (re.match("Total",line) or re.match("Unicode Encode Errors",line) or re.match("Unicode Decode Errors", line)): 
                    continue
                
                data += [line[:-1].split('\t')]

            for row in data:
                #print("ROW0: ", row[0])
                #print("ROW1: ", row[1])
                #print("ROW3: ", row[3])
                # Skip the lines with known text lines to be eliminated
                if (re.match("Total features",str(row))):
                    ##print("skip ")
                    continue

                filename = "Unkown"
                feature = "Unkown"
                position = "Unkown"
               
                ##print("ROW LEN: ", len(row)) 
                # Some lines in the annotated_xxx.txt have less than three
                # columns where filename or feature may be missing.
                if len(row) > 3:
                    ##print("filename: ", row[3])
                    filename = row[3]
                else:
                    ##print("Unknown filename: LEN:", len(row))
                    filename = "Unkown"

                if len(row) > 1:
                    feature = row[1]
                    ##print("feature: ", row[1])
                else:
                    feature = "Unkown"

                position = row[0]

                self.bc_write_column(w[0],6,filename,fill)
                self.bc_write_column(w[1],6,position,fill)
                self.bc_write_column(w[2],6,feature,fill)
                ## self.cell(w[0],6,filename,'LR',0,'L',fill)
                ## self.cell(w[1],6,position,'LR',0,'L',fill)
                ## self.cell(w[2],6,feature,'LR',0,'L',fill)
                self.ln()
                fill=not fill

                # Start from a new page with header names once
                # reached max_entries allowed per page.
                ##print("linenum, max", linenum, DirReport.max_entries_per_page )
                bc_table_end_page(self, linenum, header, w)
                linenum+=1
            #Closure line
            self.cell(sum(w),0,'','T')
            return

# Class PDF to write the report to a PDF file.
# It uses the python-3 port of FPDF software from 
# https://bitbucket.org/cyraxjoe/py3fpdf. 
class PDF(FPDF):
        def header(this):
                # Logo
                this.image('FinalBitCuratorLogo-NoText.png',10,8,33)
                # Arial bold 15
                this.set_font('Arial','B',15)
                # Move to the right
                this.cell(80)
                # Title
                # FIXME: Replace the title with a better name :)
                this.cell(70,10,'Files and Features',1,0,'C')
                # Line break
                this.ln(20)

        # Page footer
        def footer(this):
                # Position at 1.5 cm from bottom
                this.set_y(-15)
                # Arial italic 8
                this.set_font('Arial','I',8)
                # Page number
                ##this.cell(0,10,'Page '+str(this.page())+'/{nb}',0,0,'C')
                this.cell(0,10,'Page '+str(this.page)+'/{nb}',0,0,'C')

        def chapter_title(self,num,label):
                #Arial 12
                self.set_font('Arial','B',12)
                #Background color
                self.set_fill_color(200,220,255)
                #Title
                self.cell(0,6,"%s"%(label),0,1,'L',1)
                #Line break
                self.ln(4)

        def chapter_body(self,name):
                #Read text file
                txt=open(name).read()
                #Times 12
                self.set_font('Times','',10)

                #Colors of frame, background and text
                self.set_draw_color(0,80,180)
                #self.set_fill_color(230,230,0)
                self.set_fill_color(200,220,255)
                self.set_text_color(220,50,50)

                #Output justified text
                self.multi_cell(0,5,txt)
                #Line break
                self.ln()
                #Mention in italics
                self.set_font('','I')
                #self.cell(0,5,'(end of excerpt)')

        def print_chapter(self,num,title,name):
                self.add_page()
                self.chapter_title(num,title)
                self.chapter_body(name)

        #
        # This function builds the table for reporting the overall statistics
        # Source : fiwalk
        #
        def make_table_stat(self, header):
                #Colors, line width and bold font
                self.set_fill_color(80,0,0)
                self.set_text_color(255)
                self.set_draw_color(128,0,0)
                self.set_line_width(.3)
                self.set_font('','B')

                w=[50,20]

                for i in range(0,len(header)):
                        self.cell(w[i],7,header[i],1,0,'C',1)
                self.ln()

                #Color and font restoration
                self.set_fill_color(224,235,255)
                self.set_text_color(0)
                self.set_font('')

                fill=0
                self.set_font('Times','',12)

                ##self.cell(w[0],6,txt="Number Of Files",'LR',0,'L',fill)
                #self.cell(w[0],6,txt="Number Of Files",align="c")
                self.cell(w[0],6,"Number of Files",'LR',0,'L',fill)
                self.cell(w[1],6,str(DirReport.numfiles),'LR',0,'L',fill)
                self.ln()

                self.cell(w[0],6,"Total Directories",'LR',0,'L',fill)
                #self.cell(w[1],6,DirReport.numfiles,'LR',0,'L',fill)
                self.cell(w[1],6,str(DirReport.dirs),'LR',0,'L',fill)
                self.ln()
              
                self.cell(w[0],6,"Total Deleted Files",'LR',0,'L',fill)
                self.cell(w[1],6,str(DirReport.deleted_files),'LR',0,'L',fill)
                self.ln()
              
                self.cell(w[0],6,"Total Unused Files",'LR',0,'L',fill)
                self.cell(w[1],6,str(DirReport.unused_files),'LR',0,'L',fill)
                self.ln()
              
                self.cell(w[0],6,"Files with Nlinks > 1",'LR',0,'L',fill)
                self.cell(w[1],6,str(DirReport.moreNumlinks),'LR',0,'L',fill)
                self.ln()
              
                self.cell(w[0],6,"Empty Files ",'LR',0,'L',fill)
                self.cell(w[1],6,str(DirReport.emptyFiles),'LR',0,'L',fill)
                self.ln()
              
                self.cell(w[0],6,"Big Files(> 1 MB) ",'LR',0,'L',fill)
                self.cell(w[1],6,str(DirReport.bigFiles),'LR',0,'L',fill)
                self.ln()

                # Closure line
                self.cell(sum(w),0,'','T')

        def bc_adjust_text_2(self, cell_text, cell_width):
            if len(cell_text) > cell_width:
                short_len = cell_width/2 - 5
                ## print("Shortlen:",len(cell_text), cell_width, short_len)
                text = cell_text[0:int(short_len)] + '...' + cell_text[-int(short_len):]
                return text
            return cell_text
           
        # Make a List of all the Deleted Files
        def make_table_delfiles(self, header):

            imgname = image_fileinfo[0] + ': ' + image_fileinfo_val[0]

            self.set_font('Times','B',16)
            self.underline = 1
            self.cell(0, 12, "Deleted Files", border=0, ln=1)
            self.underline = 0
            self.set_font('Times','B',10)
            self.cell(0, 12, imgname , border=0, ln=1)

            #Colors, line width and bold font
            self.set_font('Times','B',12)
            self.set_fill_color(100,0,0)
            self.set_text_color(255)
            self.set_draw_color(128,0,0)
            self.set_line_width(.3)
            self.set_font('','B')

            w = [12,150]
            for i in range(0,len(header)):
                    self.cell(w[i],7,header[i],1,0,'C',1)
            self.ln()

            #Color and font restoration
            self.set_fill_color(224,235,255)
            self.set_text_color(0)
            self.set_font('Times','',8)
            

            fill=0
            num_deleted_files = 0
            for i in range(0, len(DirReport.myDictList)):
                if DirReport.myDictList[i]['unalloc']:
                    num_deleted_files+=1
                    ## print("D: Deleted File: ", num_deleted_files, DirReport.myDictList[i]['filename'])    
                    self.cell(w[0],6,str(num_deleted_files),'LR',0,'L',fill)
                    mystr = (DirReport.myDictList[i]['filename'])
                    text = self.bc_adjust_text_2(mystr, w[1])
                    self.cell(w[1],6,text,'LR',0,'L',fill)
                    self.ln()
                    fill=not fill
                    bc_table_end_page(self, num_deleted_files, header, w)

                #Closure line
            self.cell(sum(w),0,'','T')
    

        def make_table(self, header):

                self.set_text_color(10)

                self.set_font('Times','B',12)
                self.underline = 1
                self.cell(0, 10, "Files and features", border=0, ln=1)
                self.underline = 0
                self.set_text_color(50)
                self.set_font('Times','',8)
                self.cell(0, 5, "Partition: Partition where the file resides", border=0, ln=1)
                self.cell(0, 5, "ID: AFF-internal identifier", border=0, ln=1)
                self.cell(0, 5, "DIR: directory:d; Regular file:r", border=0, ln=1)
                self.cell(0, 5, "Size: Size of the file in bytes", border=0, ln=1)
                self.cell(0, 5, "Deleted: If the file is Deleted ", border=0, ln=1)
                #Colors, line width and bold font
                self.set_fill_color(100,0,0)
                self.set_text_color(255)
                self.set_draw_color(128,0,0)
                self.set_line_width(.3)
                self.set_font('','B')

                #Header
                w=[60,20,10,15,12,30,50]

                for i in range(0,len(header)):
                        self.cell(w[i],7,header[i],1,0,'C',1)
                self.ln()

                #Color and font restoration
                self.set_fill_color(224,235,255)
                self.set_text_color(0)
                self.set_font('')

                fill=0
                #for row in range(DirReport[0] to DirReport.myDictList[array_index]):
                self.set_font('Times','',8)
                for i in range(0, DirReport.array_ind-1):
                    ## FIXME: Make the filename wrap around if it is longer than w[0]
                    #self.cell(w[0],6,DirReport.myDictList[i]['filename'],'LR',0,'L',fill)
                    column = 6
                    if len(DirReport.myDictList[i]['filename']) > w[0]:
                        # FIXME: wrap-around hack till hover-text is implemented. 
                        # See template.py for example of usig multi_cell
                        ##self.multi_cell(w[0],6,DirReport.myDictList[i]['filename'],'LR',0,'L',fill)
                        ## print("D: Length exceeded column width: ", 
                            ## len(DirReport.myDictList[i]['filename']), w[0])
                        text = DirReport.myDictList[i]['filename']
                        # FIXME: For some reason, the actual table column width
                        # seems much lesser than w[0] - like 45. So hardcoded
                        # for now till explored the reason.
                        text = text[0:20] + '...' + text[-20:]
                        self.cell(w[0],6,text,'LR',0,'L',fill)
                        
                    else:
                        self.cell(w[0],6,DirReport.myDictList[i]['filename'],'LR',0,'L',fill)
      
                    ### The following is supposed to trim the characters to the
                    ### size available. But it is removing all charaters if the
                    ### text size exceeds w[0]  - FIXME

                    ###text = DirReport.myDictList[i]['filename']
                    ###text = self.multi_cell(w=w[0], h=6, txt=text,
                                      ###align='L', split_only=True)[0]
                    ###self.cell(w[0],6,text,'LR',0,'L',fill)
                    

                    self.cell(w[1],column,DirReport.myDictList[i]['partition'],'LR',0,'L',fill)
                    self.cell(w[2],column,DirReport.myDictList[i]['name_type'],'LR',0,'L',fill)
                    self.cell(w[3],column,DirReport.myDictList[i]['filesize'],'LR',0,'L',fill)
                    if DirReport.myDictList[i]['unalloc']:
                        self.cell(w[4],column,'YES','LR',0,'C',fill)
                    elif DirReport.myDictList[i]['alloc']:
                        self.cell(w[4],column,'NO','LR',0,'C',fill)

                    self.cell(w[5],column,DirReport.myDictList[i]['mode'],'LR',0,'L',fill)
                    if len(DirReport.myDictList[i]['libmagic']) > w[6]:
                        # FIXME: wrap-around hack till hover-text is implemented. 
                        text = DirReport.myDictList[i]['libmagic']
                        text = text[0:20] + '...' + text[-15:]
                        self.cell(w[6],column,text,'LR',0,'L',fill)
                    else:
                        self.cell(w[6],column,DirReport.myDictList[i]['libmagic'],'LR',0,'L',fill)
                    self.ln()
                    fill=not fill

                    # Start from a new page with header names once
                    # reached max_entries allowed per page.
                    bc_table_end_page(self, i, header, w)

                # Closure line
                self.cell(sum(w),0,'','T')

def create_report_file(input_file, annotated_file):

    # Table header
    ## print("D: Report FEATURE FILE ", annotated_file)

    # Table column headers
    tab_header_feat = ['Filename', 'position','Feature ']

    pdf = PDF_BE()
    pdf.compress = False
    pdf.add_page()
    pdf.make_table_feat(input_file,tab_header_feat)

    # Name the pdf file: Remove the first 10 charaxters: "annotated_"
    # and the last 4 characters: ".txt" and add :.pdf" in the suffix.
    ## print("D: LEN: ", len("annotated_"), len(annotated_file))
    pdf_file = PdfReport.outdir +'/' + annotated_file[10:-3] + 'pdf'
    pdf.output(pdf_file,'F')
    ## print("D: PDF: Creating PDF File: ", pdf_file)
    bc_addToReportFileList(pdf_file)
    return(pdf_file)

class PdfReport:
    domain_list_all = []
    domain_list = []
    domain_histo_list = []
    reportFiles = 0
 
    # Feature file reports: Two separeate sets are maintained - one for 
    # feature report files and one for all the rest. The latter is a fixed
    # set, where are the number of feature report files depends on the bulk-
    # extractor output (and hence the aff image in question).  

    # Two sets are defined for feature list: one for a flag to indicate
    # if the user wants to report that feature. Second, to let the user
    # set how many lines of each feature they want to be idsplayed in the report.
    default_config = False
    bc_config_feature = {}
    bc_config_feature_lines = {}

    # he following is a set of all non-feature pdf report files. It is a 
    # growing set. Add more as and when new reports are added.
    bc_config_report_files = {'bc_format_bargraph':0,'FiwalkReport':0, \
                              'FiwalkDeletedFiles':0,'BeReport':0}

    # The following is a corresponding set with the number of lines
    # to be reported in each file, being the value of each element.
    bc_config_report_lines = {'bc_format_bargraph':0,'FiwalkReport':0, \
                              'FiwalkDeletedFiles':0,'BeReport':0}

    def __init__(self,fn, use_config_file):
 
        import os.path,glob
        self.name = fn
        ## print("D:PdfReport:init: Opted to Use config file?: ", use_config_file)
        default_config = False
        
        if os.path.isdir(fn):
            ## print("D:PdfReport:init: Yes output file Is a Directory ", fn)
            self.dname = fn
            self.files = set([os.path.basename(x) for x in glob.glob(os.path.join(fn,"*.txt"))])

            num_features = len(self.files)
            temp_feature_list = list(self.files)
            ## print("D:PdfReport:init: feature :", self.files)
            ## print("D:PdfReport:init: num_features:", len(temp_feature_list))

        # Initialize the array now that we know the number of elements
        for i in range(0,len(self.files)):
            filename = temp_feature_list[i]

            # ex: annotated_email.txt ==> email
            filename = filename[10:-4]
            self.bc_config_feature[filename] = 0
            self.bc_config_feature_lines[filename] = 0

        # Open the Configuration File: If it doesn't exist, default 
        if use_config_file == 'Y' or use_config_file == 'y':
            if (os.path.exists("bc_report_config.txt") == False):
                print("Info: Config file bc_report_config.txt does not exist. Using Default parameters")
                default_config = True
        else:
            # Config file not specified
            print("D: Config File not specified. Using defaults")
            default_config = True

        if default_config == False:
            ifd = open("bc_report_config.txt","r")
            for line in ifd:
                if is_comment_line(line):
                    continue # eliminate comments

                line1 = re.split(":", line)
    
                # Set the flag for the particular feature to 1 indicating
                # the user wants to see the report for this feature.
                if line1[0] == 'F':
                    ## Test if line1[1] is a legitimate feature
                    if line1[1] in self.bc_config_feature:
                        ## print("D:PdfReport:init: Setting bc_config_feat %s to 1 " % line1[1])
                        self.bc_config_feature[line1[1]] = 1
    
                        # if the third field is 0, print all the lines in the
                        # feature file. Otherwise print what the number says.
                        self.bc_config_feature_lines[line1[1]] = int(line1[2]) 
                    else:
                        print("Info: Feature %s does NOT exist" % line1[1])
                                  
    
                elif line1[0] == 'R':
                    ## Test if line1[1] is a legitimate report file
                    if line1[1] in self.bc_config_report_files:
                        ## print("D: Setting bc_config_report_file %s to 1 " % line1[1])
                        self.bc_config_report_files[line1[1]] = 1
                        self.bc_config_report_lines[line1[1]] = int(line1[2])
                    else:
                        print("Info: Report file %s is not legitimate" % line1[1])
                        print("Info: Fix the config file")
              
        else:
            print("D: Using default Config values ")
            # Default config: Report the first five feature files and
            # all of the non-feature files     
            num_features = len(temp_feature_list)
            report_features = num_features
            if num_features > 5:
                report_features = 5

            for i in range(0,report_features-1):
                filename = temp_feature_list[i]

                # ex: annotated_email.txt ==> email
                filename = filename[10:-4]
                self.bc_config_feature[filename] = 1
                # Report all the lines:
                self.bc_config_feature_lines[filename] = 0

            self.bc_config_report_files['bc_format_bargraph'] = 1
            self.bc_config_report_files['FiwalkReport'] = 1
            self.bc_config_report_files['FiwalkDeletedFiles'] = 1
            self.bc_config_report_files['BeReport'] = 1
                    

        print("D: Repotring the following files: ")
        print(self.bc_config_feature)
        print(self.bc_config_feature_lines)
        print(self.bc_config_report_files)
        print(self.bc_config_report_lines)

    def open(self,fname,mode='r'):
        print("DEBUG: OPEN= %s " % fname, self);
            
    def be_process_generate_report(self, fn, display_option1):
        ## print("D: be_process_generate_report: ", fn.outdir, fn, display_option1)
        PdfReport.outdir = fn.outdir

        # Final output will be in pdf form. Text is retained for sometime 
        ofn = fn.outdir + ".txt"

        if os.path.exists(ofn):
            # Sunitha: Find out how to remove the file instead of 
            # annoying the user.
            raise RuntimeError(ofn+" exists")

        of = open(ofn,"wb")

        # go through every line of each annotated file, look for 
        # the pattern and write to the report file.
        for annotated_file in self.files:
            ## print ("D: Creating pdf file for: ", annotated_file)
            input_file = fn.outdir + '/' + annotated_file

            # Look at the config file to see if the user wants a
            # report file. If not, skip to the next feature.
            feature = annotated_file[10:-4]
            if PdfReport.bc_config_feature[feature] == 0:
                ## print("D:be_process_generate_report: NOT Reporting feature ", feature)
                continue

            ifd = open(input_file, "r")
            linenumber = 0
            of.write(bytes(annotated_file, 'UTF-8')) 
            of.write(b";") 

            for line in ifd:
                linenumber+=1
                if is_comment_line(line):
                    continue # eliminate comments

                match_and_write(of, line, "Total features input", 1)
                match_and_write(of, line, "Total features located to files", 1)
                match_and_write(of, line, "Total features in unallocated space" ,1)
                match_and_write(of, line, "Total features in compressed regions", 0)

                if ((fnmatch.fnmatch(line, 'Total*') or
                    (fnmatch.fnmatch(line, 'Unicode*')))):
                    continue
                else:
                    bc_analyze_lines(of, line, input_file)

            # Create a report file for this feature
            pdf_file = create_report_file(input_file, annotated_file)

        of.close()
        return

def fw_get_file_info(line1):
    for i in range(0, (len(image_fileinfo)-1)):
        if line1[0] in image_fileinfo[i]:
            image_fileinfo_val[i] = line1[1]
            ##print ("II: line10 is skip_lines0, VAL", i, image_fileinfo[i], image_fileinfo_val[i])
            break
    ## else:
        ## print("D: fw_get_file_info: No MATCH", line1[0], line1[1])
        
        

image_fileinfo_val = {}
image_fileinfo = ['image_filename', 'sectorsize','pagesize','acquisition_seconds', 'partition_offset','block_size','ftype','ftype_str','block_count','first_block','last_block']

# This function makes a dictionary datastructure of the contents of
# of the input file, which has the file attributes for every file found.
# We will make an array of dictionaries. Each dictionary is a set of the 
# attributes for each file. The List myDictArrayList has the dictionary as 
# each of its element. So it is essentially a 2-dimentional array.
# Number of elements in each dictonary is the number of attributes for each 
# file from the fiwalk output. The number of elements in the big array 
# myDictArrayList is the number of files in the fiwalk output file.

def make_dict(linenum, line):
    ##if linenum < 20:
        ##return
    if not line.strip():
        ##print("EMPTY LINE")
        return
    line1 = re.split(":", line)
    if 'md5' in line1[0] or 'sha1' in line1[0]:
        ## print("D:make_dict: SKIPPING MD5 and SHA1: line1:", line1[0])
        return
    if line1[0] in image_fileinfo:
        fw_get_file_info(line1) 
        return

    # If the line has "filename", it is the beginning of a new array element
    # We will append the previous element to the dictionary. But if this is
    # the very first array element, there is nothing to append. So the flag
    # "is_first_file" is used which is toggeld here to indicate the subsequent
    # one is not the first element.
    #
    if line1[0] in 'filename': #Next sub-array 
        ##FIXME: Need to eliminate special files (with dots and dotdots)
        ## If the first char is . or .. ignore
        #print("line10-filename: ", str(line1[1]))

        if line1[1][0] == ".":
            print("dotted filename: ", line1[1]) 

        DirReport.array_ind = DirReport.array_ind + 1
        if DirReport.is_first_file==True:
            DirReport.is_first_file = False
        else:
            ## print("D: make_dict: NOT first file anymore is_first_file flag is false ")
            ## for j in range(0, len(DirReport.dict_array)):
                ## print(DirReport.dict_array[j])
            ## print("DEBUG: Last element: ARRAY INDEX NOW IS: ", line1[0], DirReport.array_ind)
            # last element added. Append the array to the dict.
            DirReport.myDictList.append({DirReport.dict_array[0]:DirReport.dict_val[0], \
                         DirReport.dict_array[1]:DirReport.dict_val[1],\
                         DirReport.dict_array[2]:DirReport.dict_val[2],\
                         DirReport.dict_array[3]:DirReport.dict_val[3],\
                         DirReport.dict_array[4]:DirReport.dict_val[4],\
                         DirReport.dict_array[5]:DirReport.dict_val[5],\
                         DirReport.dict_array[6]:DirReport.dict_val[6],\
                         DirReport.dict_array[7]:DirReport.dict_val[7],\
                         DirReport.dict_array[8]:DirReport.dict_val[8],\
                         DirReport.dict_array[9]:DirReport.dict_val[9],\
                         DirReport.dict_array[10]:DirReport.dict_val[10],\
                         DirReport.dict_array[11]:DirReport.dict_val[11],\
                         DirReport.dict_array[12]:DirReport.dict_val[12],\
                         DirReport.dict_array[13]:DirReport.dict_val[13],\
                         DirReport.dict_array[14]:DirReport.dict_val[14],\
                         DirReport.dict_array[15]:DirReport.dict_val[15],\
                         DirReport.dict_array[16]:DirReport.dict_val[16],\
                         DirReport.dict_array[17]:DirReport.dict_val[17],\
                         DirReport.dict_array[18]:DirReport.dict_val[18],\
                         DirReport.dict_array[19]:DirReport.dict_val[19],\
                         DirReport.dict_array[20]:DirReport.dict_val[20],\
                         DirReport.dict_array[21]:DirReport.dict_val[21],\
                         DirReport.dict_array[22]:DirReport.dict_val[22]})

    for ind in range (0, (len(DirReport.dict_array)-1)):
        if line1[0] in DirReport.dict_array[ind]:
            ## print("D: make_dict: Adding line1[0], ind: ", line1[0], line1[1].rstrip(), ind) 
            ## print("D: make_dict: INDEX", DirReport.array_ind, line1[0])

            # Either alloc or unalloc will be present for any file. So set the
            # the value of the other one to 0, for future reference.
            if line1[0] in 'alloc':
                DirReport.dict_val[6] = 0     
            elif line1[0] in 'unalloc':
                DirReport.dict_val[5] = 0     

            DirReport.dict_val[ind] = line1[1].rstrip() 
            break
        
def print_dict():
    print(" LENGTH: ", len(DirReport.myDictList))
    for index in range(len(DirReport.myDictList)):
        print("PrintDict: INDEX: filename", DirReport.myDictList[index]['filename'])
        if index == 10:
            break

def match_file_write(of, line, pattern, linenum):
        print("Fn:match_file_write:", linenum)
        if re.match("filename: ",line):
            line1 = re.split(":", line)
            of.write(bytes(line1[1], 'UTF-8')) 

# Normalizing function. Here we need just thes stripping.
def normalize(s):
    #for p in string.punctuation:
        #s = s.replace(p, '')
 
    #return s.lower().strip()
    return s.strip()
#
# Function: get_file_info()
# Parses the line and populates the DirReport class with the info.
#
def get_file_info(line):
    if re.match("name_type: ",line):
        line1 = re.split(":", line)
        if "r" in line1[1]:
            DirReport.numfiles = DirReport.numfiles + 1
        elif "d" in line1[1]:
            DirReport.dirs = DirReport.dirs + 1
    elif re.match("unalloc", line):
        line1 = re.split(":", line)
        if int(line1[1]) == 1:
            DirReport.deleted_files = DirReport.deleted_files + 1
    elif re.match("libmagic", line):
        line1 = re.split(":", line)
        fileformat = normalize(line1[1])

        # traverse through the dictionary dictFileFmtList and look
        # for fileformat. If found, increment its value by 1.
        for i in range(0,(len(DirReport.dictFileFmtArray) - 1)):
            mystr = DirReport.dictFileFmtArray[i]
            ## print("D: i: %d FMT-a: %s filefirmat:%s " % (i,  mystr, fileformat))
            if re.match(mystr, fileformat):
                # match found. Increment the value
                DirReport.dictFileFmtVal[i] += 1

                break
        else:
            print("Not Found fileformat: ", fileformat)
    elif re.match("filesize", line):
        line1 = re.split(":", line)
        if int(line1[1]) == 0:
            DirReport.emptyFiles = DirReport.emptyFiles + 1
        if int(line1[1]) > 1024*1024:
            DirReport.bigFiles = DirReport.bigFiles + 1

# Write the file info to an output file
# Not really needed for pdf report generation, but kept it for debugging 
# purposes
def write_file_details(of):
    ## print("D: NUMBER OF ARRAY ELEMENTS: ", DirReport.array_ind)
    of.write(b"Filename \t\t\t part \t id \t dir? \t size \t alc? \t usd? \t meta \t mode \t nlink")
    of.write(bytes("\n=====================================================\n\n", 'UTF-8'))
    for i in range(0, DirReport.array_ind-1):
      #for j in range(0, 21):
        #of.write(bytes(line1[1], 'UTF-8')) 
        of.write(bytes(DirReport.myDictList[i]['filename'], 'UTF-8'))
        of.write(b"\t\t\t")
        of.write(bytes(DirReport.myDictList[i]['partition'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['id'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['name_type'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['filesize'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['alloc'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['used'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['meta_type'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['mode'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['nlink'], 'UTF-8'))
        of.write(b"\n")

def generate_bar_graph(item_dict):
    fig = p.figure()
    ax = fig.add_subplot(1,1,1)

    y = []
    group_labels = []

    ## print("D: Generate_bar_graph: Dict:Length: %d, %s"
                       ## % (len(item_dict), item_dict.items())) 

    # Simple lambda expression to sort the items in ascending order (then reverse it)
    sorted_items = sorted(item_dict.items(), key=lambda x: x[1])
    sorted_items.reverse()
    for i in sorted_items:
       y.append(i[1])
       group_labels.append(i[0])
 
    # calculate the number of bars required
    N = len(y)
    # generate a range of numbers (just a placeholder before we relabel)
    ind = range(N)

    # set up the actual graphing
    ax.bar(ind,y,width=0.3,facecolor = '#888888',align = 'center',ecolor = 'black')
    ax.set_ylabel('Counts')
    ax.set_title('File counts (by format)')
    ax.set_xticks(ind)
    ax.set_xticklabels(group_labels)
    fig.autofmt_xdate()
 
    outfile = DirReport.outdir + '/bc_format_bargraph.pdf'
    pp = PdfPages(outfile)
    bc_addToReportFileList(outfile)
    pp.savefig(fig)
    pp.close()
    os.system("evince ./bc_format_bargraph`.pdf")

def bc_draw_histogram_fileformat(item_dict):
    generate_bar_graph(item_dict)

#
# Fiwalk generates info about the image and puts it on top of the output file
# before writing the individual file-info. This is written on top of the 
# PDF file as well. 
#
def fw_print_fileinfo(pdf):
    pdf.set_text_color(2)
    pdf.set_draw_color(10,0,0)
    pdf.set_font('Times','B',16)
    pdf.underline = 1

    pdf.cell(0, 10, "File Information", border=0, ln=1)
    pdf.underline = 0
    for i in range(0, (len(image_fileinfo)-1)):
        pdf.set_font('Times','B',14)
        left_text = image_fileinfo[i] + ': '
        right_text =  image_fileinfo_val[i] 
        pdf.cell(50,5,left_text)
        pdf.set_font('Times','I',14)
        pdf.multi_cell(0,5, right_text)
        pdf.cell(0,5, ln=1)

#
# List the deleted files from the fiwalk outputfile
#
def fw_list_deleted_files():
    # Traverse through myDictList, look for unalloc=1 and print the filename
    ## print("D: Length of myDictList : ", len(DirReport.myDictList))
    num_deleted_files = 0
    for i in range(0, len(DirReport.myDictList)):
        if DirReport.myDictList[i]['unalloc']:
            num_deleted_files+=1
            ## print("D: Deleted File: ", num_deleted_files, DirReport.myDictList[i]['filename'])    
    
#
# This class is used to report information from the output file created 
# by fiwalk program with -T option. 
#
class DirReport:
    index = 0
    from collections import namedtuple
    MyStruct = namedtuple("MyStruct", "filename partition id name_type filesize alloc")
    numfiles = 0
    files = 0
    dirs = 0
    deleted_files = 0
    unused_files = 0
    moreNumlinks = 0
    emptyFiles = 0
    bigFiles = 0
    #dict_files = {'filename','size', 'mode', 'uid', 'gid', 'seq', 'created'};
    dict_array = ["filename", "partition", "id", "name_type", "filesize", \
                  "alloc", "unalloc", "used", "inode", "meta_type", "mode", \
                  "nlink", \
                  "uid", "gid", "mtime", "mtime_txt", "ctime", "ctime_txt",\
                  "atime", "atime_txt", "crtime", "crtime_txt", "libmagic", "seq"] 
    dict_val = {}
    myDictList = []

    dictFileFmtList = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    dictFileFmtVal = {}
    dictFileFmtA = ["empty","data","none",\
                        "AppleDouble",\
                        "XML",\
                        "SQLite3x",\
                        "nISO-EA-NLT",\
                        "NISO-EA",\
                        "Hitachi",\
                        "PDP-11",\
                        "ISO-8859",\
                        "ISO-8859-NLT",\
                        "ASCII",\
                        "PDF1.4",\
                        "DOSCOM" ]
    dictFileFmt = {"empty","data","none",\
                        "AppleDouble",\
                        "XML",\
                        "SQLite3x",\
                        "nISO-EA-NLT",\
                        "NISO-EA",\
                        "Hitachi",\
                        "PDP-11",\
                        "ISO-8859",\
                        "ISO-8859-NLT",\
                        "ASCII",\
                        "PDF1.4",\
                        "DOSCOM" }
    dictFileFmtArray = ["empty","data","none",\
                        "AppleDouble encoded Macintosh file",\
                        "XML document text",\
                        "SQLite 3.x database",\
                        "Non-ISO extended-ASCII text, with no line terminators",\
                        "Non-ISO extended-ASCII text",\
                        "Hitachi SH big-endian COFF object, not stripped",\
                        "PDP-11 UNIX/RT ldp",\
                        "ISO-8859 text",\
                        "ISO-8859 text, with no line terminators",\
                        "ASCII text","ASCII text, with no line terminators",\
                        "PDF document, version 1.4",\
                        "DOS executable (COM)" ]
    
    arrayElementNum = 0
    array_ind = 0
    dont_start_yet = True
    is_first_file = True
    page = 0
    max_entries_per_page =30 
    outdir = ''
    def __init__(self,fn):

 
        import os.path,glob
        self.name = fn
        ## print("D: FN: ", fn)
        if os.path.isfile(fn):
            ## print("D: YES The Fiwalk Txt file EXISTS ", fn)
            self.dname = fn
            self.files = set([os.path.basename(x) for x in glob.glob(os.path.join(fn,"*.txt"))])

            #print("D: FILES: ", self.files)

        # Initialize the values of the dict elements
        for ind in range (0, (len(DirReport.dict_array)-1)):
            DirReport.dict_val[ind] = 0 
            #DirReport.dictFileFmtList[ind] = 0 

        for ind in range (0, (len(DirReport.dictFileFmtArray)-1)):
            DirReport.dictFileFmtVal[ind] = 0 

    def open(self,fname,mode='r'):
        ## print("DEBUG: OPEN= %s " % fname, self);
        print("D = %s " % fname);

    ###def process_generate_report_fiwalk(self, fn, display_option1, display_numfiles):
    def process_generate_report_fiwalk(self, fn):
        print("DEBUG: ", fn.outdir, fn)
        ofn = fn.outdir + "FI.txt"
        ofn_pdf = fn.outdir + "FI.pdf"

        # Output text file created using bulk-extractor output
        # We will use this text file to populate the pdf report
        ofn_be = fn.outdir + ".txt"
        DirReport.outdir = fn.outdir

        pdf=PDF()
        pdf.compress = False
        pdf.set_font('Arial','B',10)

        if os.path.exists(ofn):
            # Sunitha: Find out how to remove the file instead of 
            # annoying the user.
            raise RuntimeError(ofn+" exists")

        of = open(ofn,"wb")
        of.write(b'Directory Structure: \n')
  
        ofn_temp = "temp_file"
        ofn_dict = "dict_file"

        # Open a temp file to write statistics
        of1 = open(ofn_temp,"wb")
        of2 = open(ofn_dict,"wb")
     
        input_file = fn.fiwalk_txtfile
        # print("D: file: ", input_file)
        ifd = open(input_file, "r")
        linenum = 0
        for line in ifd:
            linenum = linenum + 1
            if is_comment_line(line):
                continue # eliminate comments

            # Add the info to the dictionary
            make_dict(linenum, line)

            ####match_file_write(of, line, "filename: ", linemum-1)
            get_file_info(line)

        ## print_dict() # Just for debugging

        # Write collected statistics to output file
        # Note:The following code is retained just for testing purpose.
        #of.seek(0,0)
        of1.write(b'Input File Name: ')
        #of.write(str(input_file))
        of1.write(bytes(input_file, 'UTF-8')) 
        of1.write(b'\n\n')
        of1.write(b'\nTotal Files:\t\t')
        of1.write(bytes(str(self.numfiles), 'UTF-8'))
        of1.write(b'\nTotal Directories:\t')
        of1.write(bytes(str(self.dirs), 'UTF-8'))
        of1.write(b'\nTotal Deleted Files:\t')
        of1.write(bytes(str(self.deleted_files), 'UTF-8'))
        of1.write(b'\nTotal Unused Files:\t')
        of1.write(bytes(str(self.unused_files), 'UTF-8'))
        of1.write(b'\nFiles with nliks > 1:\t')
        of1.write(bytes(str(self.moreNumlinks), 'UTF-8'))
        of1.write(b'\nEmpty Files:\t\t')
        of1.write(bytes(str(self.emptyFiles), 'UTF-8'))
        of1.write(b'\nBig Files : \t')
        of1.write(bytes(str(self.bigFiles), 'UTF-8'))
        of1.write(b'\n\n')

        write_file_details(of)

        of.close()
        of1.close()
        of2.close()

        # Data for Histogram
        # The frequency of each file-format type is mapped into a histogram/plot.
        # We calculate the number of files in each file format here.
        # Looking at a couple of sample data, 15 file formats are identified.
        # More can be added as they are found. Look at dictFleFmtArray for the
        # identifed list of formats.

        self.dictFileFmt = dict()
        for i in range(0, (len(self.dictFileFmtArray)-1)):
            # FIXME: use list(dictFileFmt) instead
            self.dictFileFmt[self.dictFileFmtA[i]] =  self.dictFileFmtVal[i]
            ## print("Debug %s Num: %d" % (self.dictFileFmtArray[i], self.dictFileFmtVal[i])) 
            ## print("Debug: dictFileFmt[%s] = %d" %(self.dictFileFmtA[i], 
                      ## self.dictFileFmt[self.dictFileFmtA[i]] ))
                              
        ## Report the bargraph only if the configuration file says so
        if PdfReport.bc_config_report_files['bc_format_bargraph']:
            ## print("D: Generating bc_format_bargraph file ") 
            bc_draw_histogram_fileformat(self.dictFileFmt)

        # Table header
        header_stat = ['Statistics','']
        header_be = ['Bulk Extractor Report Files','Feature Instances','FLTF','FIUF','FICR']
        header_files = ['filename','partition','DIR','size','Deleted','ntfs-mode','filetype']
        
        tab_header_delfiles = ['Sl Num', 'Deleted File']

        ## Report the Fiwalk Report file only if the config file says so
        if PdfReport.bc_config_report_files['FiwalkReport'] == 1:
            ## print("D: Generating Fiwalk Report")

            # Write the txt files to pdf file
            pdf.set_title("Bitcurator Report")
 
            # Print the information about the input image being analyzed
            pdf.set_font('Arial','',10)
            pdf.add_page()
            fw_print_fileinfo(pdf)

            # Print the statistics first
            pdf.set_font('Arial','',10)
            pdf.add_page()
            pdf.make_table_stat(header_stat)

            pdf.set_font('Arial','',10)
            pdf.add_page()
            pdf.make_table(header_files)
            pdf_file = fn.outdir + '/FiwalkReport.pdf'
            pdf.output(pdf_file,'F')
            bc_addToReportFileList(pdf_file)
        
        # Generate the Report of deleted files
        ## Debug:
        ## fw_list_deleted_files()

        ## Report the Deleted Files only if the config file says so
        if PdfReport.bc_config_report_files['FiwalkDeletedFiles'] == 1:
            ## print("D: Generating Deleted Files Report")
            pdf=PDF()
            pdf.compress = False
            pdf.set_font('Arial','B',10)
            pdf.add_page()
            y = pdf.get_y()
            pdf.set_y(y+10)
            pdf.make_table_delfiles(tab_header_delfiles)
            pdf_file = fn.outdir + '/FiwalkDeletedFiles.pdf'
            pdf.output(pdf_file, 'F')
            bc_addToReportFileList(pdf_file)

        ## Now add the info from bulk-extractor output (be_ofn)
        ## Report the Deleted Files Report file only if the config file says so
        if PdfReport.bc_config_report_files['BeReport'] == 1:
            ## print("D: Generating BE Report file BeReport.pdf")
            pdf=PDF_BE()
            pdf.compress = False

            pdf.set_font('Arial','B',10)
            pdf.add_page()
            y = pdf.get_y()
            pdf.set_y(y+10)
            pdf.set_text_color(128)
            pdf.make_table_be(header_be, ofn_be)

            pdf_file = fn.outdir + '/BeReport.pdf'
            pdf.output(pdf_file,'F')
            bc_addToReportFileList(pdf_file)

        ## print("Printing the Generated PDF files ")
        bc_printReportFileList()
