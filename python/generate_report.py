#!/usr/bin/python
# coding=UTF-8
# 
'''
File: bc_generate_report.py
A module for working with bulk_extractor

This module works with bulk_extractor and identify_filenames modules
and extracts the annotaed files  generated by the identify_filenames
module and generates a report.

Note-1: It uses the python-3 port of FPDF software from 
https://bitbucket.org/cyraxjoe/py3fpdf. So PYTHONPATH should include
the path to this directory.

Note-2: The following sequence is required to run this report:
1. Generate output feature files using Bulk Extractor
Ex: bulk_extractor 
    ~/Research/TestData/M57-Scenario/usbflashdrives/jo-work-usb-2009-12-11.aff 
    -o ~/Research/TestData/BEOutputs/jow-output

2. Generate the Text output from the fiwalk utility.
Ex: fiwalk -f -X /home/sunitha/Research/TestData/BEOutputs/jo-work-usb-fi.xml 
   -T /home/sunitha/Research/TestData/BEOutputs/jo-work-usb-fi_T 
    jo-work-usb-2009-12-11.aff
Ex2: fiwalk -f -X icharlie_F.xml -T icharlie_FT ~/Research/TestData/M57-Scenario/usbflashdrives/charlie-work-usb-2009-12-11.aff

3. Generate the annotated files from the identify_filenames utility
Ex: python3 identify_filenames.py --all --imagefile 
    ~/Research/TestData/M57-Scenario/usbflashdrives/jo-work-usb-2009-12-11.aff 
    ~/Research/TestData/BEOutputs/jow-output 
    ~/Research/TestData/BEOutputs/ident-jow-output
4. Run the generate_reports script to generate the pdf reports.
    (this uses the annotated feature files created in step-3, fiwalk output
     created in Step-2, and bulk-extractor outputs created in step-1)
Ex: python3 generate_report.py --pdf_report
       --fiwalk_txtfile ~/Research/TestData/BEOutputs_131/charlie_fi_FT.txt  
       --annotated_dir ~/Research/TestData/BEOutputs_131/annotated_charlie_output
       --outdir ~/Research/TestData/BEOutputs_131/charlie_rep_outdir
'''

__version__ = "1.3.0"

b'This module needs Python 2.7 or later.'
import zipfile,os,os.path,glob,codecs
from fpdf import *
import re
import os
import fnmatch
from collections import namedtuple
import string
import datetime
import sys
import bc_utils
import bc_config
import bc_pdf
import bc_graph
from bc_utils import filename_from_path
try:
    from argparse import ArgumentParser
except ImportError:
    raise ImportError("This script requires ArgumentParser which is in Python 2.7 or Python 3.0")

# A list of the report files is maintained, to keep track of which ones
# are actually reported, based on the configuration.
reportFiles = 0

input_image_name = ''
image_fileinfo = ['image_filename', 'sectorsize','pagesize','acquisition_seconds', 'partition_offset','block_size','ftype','ftype_str','block_count','first_block','last_block']

image_info = {'image_filename':0, 'sectorsize':0,'pagesize':0,'acquisition_seconds':'', 'partition_offset':0,'block_size':0,'ftype':0,'ftype_str':0,'block_count':0,'first_block':0,'last_block':0}

#
# Class PDF_BE to write the report to a PDF file.
# It uses the Bulk-Extractor output information as its input.
# It uses the python-3 port of FPDF software from 
# https://bitbucket.org/cyraxjoe/py3fpdf. 
#
class PDF_BE(FPDF):
    def header(this):
        bc_pdf.make_header(this,PdfReport.logo, 'Bulk Extractor Features') 

    # Page footer
    def footer(this):
        # Position at 1.5 cm from bottom
        this.set_y(-15)
        # Arial italic 8
        this.set_font('Arial','I',8)
        # Page number
        this.cell(0,10,'Page '+str(this.page),0,0,'C')
    
    #
    # This function builds the table for reporting the information 
    # gathered from the feature files created by bulk-extractor
    #
    def make_table_be(self, header,filename):
        self.set_text_color(20)
        self.set_font('Times','I',10)

        self.underline = 1
        self.set_x(-80)
        self.cell(0, 10, 'Note:', border=0, ln=1)
        self.underline = 0
        self.set_x(-80)
        self.cell(0, 5, 'FIUF:Total features unallocated to files', border=0, ln=1)
        self.set_x(-80)
        self.cell(0, 5, 'FIUF:Total features unallocated to files', border=0, ln=1)
        self.set_x(-80)
        self.cell(0, 5, 'FICR:Total features in compressed regions', border=0, ln=1)
                
        #Colors, line width and bold font
        self.set_fill_color(135,0,0)
        self.set_text_color(255)
        self.set_draw_color(128,0,0)
        self.set_line_width(.3)
        self.set_font('','B')

        #Header (hardcoded columb width)
        w=[50,30,20,20,20]

        for i in range(0,len(header)):
            self.cell(w[i],7,header[i],1,0,'C',1)
        self.ln()

        #Color and font restoration
        self.set_fill_color(224,235,255)
        self.set_text_color(0)
        self.set_font('')

        fill=0
        self.set_font('Times','',12)

        data=[]
        for line in open(filename):
            data += [line[:-1].split(';')]

        for row in data:
            self.cell(w[0],6,row[0],'LR',0,'L',fill)
            self.cell(w[1],6,row[1],'LR',0,'C',fill)
            self.cell(w[2],6,row[2],'LR',0,'C',fill)
            self.cell(w[3],6,row[3],'LR',0,'C',fill)
            self.cell(w[4],6,row[4],'LR',0,'C',fill)
            self.ln()
            fill=not fill

        #Closure line
        self.cell(sum(w),0,'','T')

    def bc_write_column(self, w,h,cell_text, fill):
        text = bc_pdf.bc_adjust_text(cell_text, w)
        self.cell(w,h,text,'LR',0,'L',fill)

    #
    # make one table per feature
    #
    def make_table_feat(self, feature_file, header):
        self.set_text_color(1)
        self.set_font('Times','B',12)
           
        fill=0

        self.cell(40, 7, 'Feature File: '+filename_from_path(feature_file), border=0, ln=1)
        self.set_font('Times','',8)
        self.underline = 0
        self.set_fill_color(224,235,255)
        self.set_text_color(0)
        self.set_draw_color(128,0,0)
        self.set_line_width(.3)

        # Filename; position; feature
        w=[65,50,75]

        for i in range(0,len(header)):
            self.cell(w[i],7,header[i],1,0,'C',1)
        self.ln()

        data=[]
        linenum = 0
        for line in open(feature_file):
            if bc_utils.is_comment_line(line):
                continue
            linenum+=1

            if (re.match("Total",line) or \
                re.match("Unicode Encode Errors",line) or \
                re.match("Unicode Decode Errors", line)): 
                continue
            
            data += [line[:-1].split('\t')]
            lendir = len(PdfReport.annotated_dir) + 1 + 10 # Adding /annotated 
            feat_filename =  feature_file[lendir:-4]
           
            # Config file sets the maxlines to 0 to report all the lines
            if (PdfReport.bc_config_feature_lines[feat_filename] != 0):
                if (linenum >= PdfReport.bc_config_feature_lines[feat_filename]):
                    # Lines reached max: Breaking
                    break 

        linenum = 0
        for row in data:
            # Skip the lines with known text lines to be eliminated
            if (re.match("Total features",str(row))):
                continue

            filename = "Unkown"
            feature = "Unkown"
            position = "Unkown"
           
            # Some lines in the annotated_xxx.txt have less than three
            # columns where filename or feature may be missing.
            if len(row) > 3:
                filename = row[3]
            else:
                filename = "Unkown"

            if len(row) > 1:
                feature = row[1]
            else:
                feature = "Unkown"

            position = row[0]

            # If it is a special file, check if the user wants it to 
            # be repoted. If not, exclude this from the table.
            if (PdfReport.bc_config_report_special_files == False) and (is_special_file(filename)):
                ## print("D: File %s is special. So skipping" %(filename))
                continue
            self.bc_write_column(w[0],6,filename,fill)
            self.bc_write_column(w[1],6,position,fill)
            self.bc_write_column(w[2],6,feature,fill)
            self.ln()
            fill=not fill

            # Start from a new page with header names once
            # reached max_entries allowed per page.
            if ((linenum>=DirReport.max_entries_per_page) &
                    (linenum%DirReport.max_entries_per_page == 0)):
            
                bc_pdf.bc_table_end_page(self, DirReport, linenum, header, w)
            linenum+=1

        #Closure line
        self.cell(sum(w),0,'','T')
        return

#
# Class PDF to write the Fiwalk report to a PDF file.
# It uses the python-3 port of FPDF software from 
# https://bitbucket.org/cyraxjoe/py3fpdf. 
#
class PDF(FPDF):
    # Page footer
    def header(this):
        bc_pdf.make_header(this,PdfReport.logo, 'File System Statistics and Files')  

    # Page footer
    def footer(this):
        # Position at 1.5 cm from bottom
        this.set_y(-15)
        # Arial italic 8
        this.set_font('Arial','I',8)
        # Page number
        this.cell(0,10,'Page '+str(this.page),0,0,'C')

    def set_table_hdr_attributes(self, w, header):
        self.set_font('Times','B',10)
        self.set_fill_color(200,0,0)
        self.set_text_color(255)
        self.set_draw_color(128,0,0)
        self.set_line_width(.3)
        self.set_font('','B')

        for i in range(0,len(header)):
            self.cell(w[i],7,header[i],1,0,'C',1)
        self.ln()
               
    def set_table_body_attributes(self):
        self.set_fill_color(224,235,255)
        self.set_text_color(0)
        self.set_font('Times','',8)

    #
    # Get the "long form" of the "short form" of the format :-)
    # Uses info from the two structures dictFileFmtVal and bcFmtDict.
    # The two structures could be combined into one in the future.
    #
    def bc_get_LongformFmt(self, short_form_fmt):
        for x in DirReport.dictFileFmtVal:
            if x == short_form_fmt:
                for y in DirReport.bcFmtDict:
                    if x == DirReport.bcFmtDict[y]:
                        return (y)

    #
    # This tabe will have the translation of the long and short forms
    # of the format name and the number of files for each format. This
    # has the supplemental information for the bar chart and combines
    # the information fron from dictFileFmtVal and bcFmtDict.
    #
    def bc_make_table_fileformat(self, header, dictFileFmtVal, bcFmtDict):
        # Header
        w=[120,30,20]
    
        self.set_font('Times','B',12)
        self.underline = 1
        self.cell(0, 6, 'File Format Table', ln=1)
    
        self.set_font('Times','',10)
        imgname = 'image_filename: ' + image_info['image_filename']
        
        self.cell(0, 6, 'Disk Image: '+filename_from_path(imgname), ln=1)
        
        #Colors, line width and bold font
        self.set_table_hdr_attributes(w, header)
        
        #Color and font restoration
        self.set_table_body_attributes()
        
        fill=0
        self.set_font('Times','',10)

        ## print("D:", dictFileFmtVal)
        ## print("D:", bcFmtDict)
        self.bc_get_LongformFmt("PDP-11")

        num_items = 0
        for i in dictFileFmtVal:
            num_items += 1
            trimmed_text = bc_pdf.bc_adjust_text(self.bc_get_LongformFmt(i), w[0])
            self.cell(w[0],6,trimmed_text,'LR',0,'L',fill)
            self.cell(w[1],6,i,'LR',0,'L',fill)
            self.cell(w[2],6,str(dictFileFmtVal[i]),'LR',0,'C',fill)
            self.ln()
            fill=not fill
            bc_pdf.bc_table_end_page(self, DirReport, num_items, header, w)

        # Closure line
        self.cell(sum(w),0,'','T')
        
                
    #
    # This function builds the table for reporting the overall statistics
    # Source : fiwalk
    #
    def make_table_stat(self, header):
        # Header
        w=[70,80]

        self.set_font('Times','B',12)
        self.underline = 1
        self.cell(0, 6, 'Technical Metadata', ln=1)
              
        self.set_font('Times','',10)
        imgname = 'image_filename: ' + image_info['image_filename']

        self.cell(0, 6, 'Disk Image: '+filename_from_path(imgname), ln=1)

        #Colors, line width and bold font
        self.set_table_hdr_attributes(w, header)

        #Color and font restoration
        self.set_table_body_attributes()

        fill=0
        self.set_font('Times','',10)
        for key in image_info:
            self.cell(w[0],6,bc_utils.stringfix(key),'LR',0,'L',fill)

            # Display just the file name for the "image_filename" key
            if (key == 'image_filename'):
                cell_text = filename_from_path(image_info[key])
            else:
                cell_text = image_info[key]

            self.cell(w[1],6,cell_text,'LR',0,'L',fill)
            self.ln()
            fill=not fill
  
        self.cell(w[0],6,"Number of Files",'LR',0,'L',fill)
        self.cell(w[1],6,str(DirReport.numfiles),'LR',0,'L',fill)
        self.ln()
        fill=not fill

        self.cell(w[0],6,"Total Directories",'LR',0,'L',fill)
        self.cell(w[1],6,str(DirReport.dirs),'LR',0,'L',fill)
        self.ln()
        fill=not fill
              
        self.cell(w[0],6,"Total Deleted Files",'LR',0,'L',fill)
        self.cell(w[1],6,str(DirReport.deleted_files),'LR',0,'L',fill)
        self.ln()
        fill=not fill
              
        self.cell(w[0],6,"Total Unused Files",'LR',0,'L',fill)
        self.cell(w[1],6,str(DirReport.unused_files),'LR',0,'L',fill)
        self.ln()
        fill=not fill
              
        self.cell(w[0],6,"Files with Nlinks > 1",'LR',0,'L',fill)
        self.cell(w[1],6,str(DirReport.moreNumlinks),'LR',0,'L',fill)
        self.ln()
        fill=not fill
              
        self.cell(w[0],6,"Empty Files ",'LR',0,'L',fill)
        self.cell(w[1],6,str(DirReport.emptyFiles),'LR',0,'L',fill)
        self.ln()
        fill=not fill
              
        self.cell(w[0],6,"Big Files(> 1 MB) ",'LR',0,'L',fill)
        self.cell(w[1],6,str(DirReport.bigFiles),'LR',0,'L',fill)
        self.ln()
        fill=not fill

        # Closure line
        self.cell(sum(w),0,'','T')

    #
    # Make a Table of all the Deleted Files
    #
    def make_table_delfiles(self, header):

        self.set_font('Times','B',16)
        self.underline = 1
        self.cell(0, 12, "Deleted Files", border=0, ln=1)
        self.underline = 0
        self.set_font('Times','B',10)
        imgname = 'Disk Image: ' + filename_from_path(image_info['image_filename'])
        self.cell(40, 7, imgname, border=0, ln=1)

        # Set Colimn width
        w = [12,150]

        #Colors, line width and bold font
        self.set_table_hdr_attributes(w, header)

        #Color and font restoration
        self.set_table_body_attributes()

        fill=0
        num_deleted_files = 0
        for i in range(0, len(DirReport.myDictList)):
            if DirReport.myDictList[i]['unalloc']:
                num_deleted_files+=1
                ## print("D: Deleted File: ", 
                ## num_deleted_files,DirReport.myDictList[i]['filename'])    
                self.cell(w[0],6,str(num_deleted_files),'LR',0,'L',fill)
                mystr = (DirReport.myDictList[i]['filename'])
                text = bc_pdf.bc_adjust_text(mystr, w[1])
                self.cell(w[1],6,text,'LR',0,'L',fill)
                self.ln()
                fill=not fill
                bc_pdf.bc_table_end_page(self, DirReport, num_deleted_files, header, w)

        #Closure line
        self.cell(sum(w),0,'','T')
    
    #
    # Make a Table of all the files with the given format type
    # Full format is what appears in the image file.
    # 
    def make_table_fmtfiles(self, header, file_format):
        imgname = 'image_filename: ' + image_info['image_filename']
        format_heading = 'Format: '+file_format

        # Write the headlines for the table:
        self.underline = 1
        self.set_font('Times','B',10)
        self.cell(0, 6, 'Disk Image: '+filename_from_path(imgname), ln=1)
        self.cell(0, 12, format_heading, border=0, ln=1)
        self.underline = 0

        # Set Colimn width
        w = [12,150]

        #Colors, line width and bold font
        self.set_table_hdr_attributes(w, header)

        #Color and font restoration
        self.set_table_body_attributes()
            
        fill=0
        num_files = 0
        for i in range(0, len(DirReport.myDictList)):
            mystr =  bc_utils.normalize(DirReport.myDictList[i]['libmagic'])

            if mystr == file_format:
                num_files+=1
                self.cell(w[0],6,str(num_files),'LR',0,'L',fill)
                mystr = (DirReport.myDictList[i]['filename'])
                text = bc_pdf.bc_adjust_text(mystr, w[1])
                self.cell(w[1],6,text,'LR',0,'L',fill)
                self.ln()
                fill=not fill
                bc_pdf.bc_table_end_page(self, DirReport, num_files, header, w)
        self.cell(sum(w),0,'','T')
        return

    #
    # Makes a consolidated report of chosen few attributes
    # of all the files listed by fiwalk
    #
    def make_table(self, header):
        self.set_text_color(10)

        self.set_font('Times','I',10)
        self.underline = 0
        self.set_x(-80)
        self.cell(0, 6, "Note: ", border=0, ln=1)
        self.set_x(-80)
           
        self.cell(0, 5, "DIR: Directory:d; Regular file:r", border=0, ln=1)
        self.set_x(-80)
        self.cell(0, 5, "Size: Size of the file in bytes", border=0, ln=1)
        self.set_x(-80)
        self.cell(0, 5, "Deleted: If the file is Deleted ", border=0, ln=1)

        #Header
        w=[60,20,10,15,12,80]

        #Colors, line width and bold font
        self.set_table_hdr_attributes(w, header)

        #Color and font restoration
        self.set_table_body_attributes()
    
        fill=0

        ## Warn the user if the length of  a feature file is > max lines
        if PdfReport.bc_max_lines_to_report and \
             DirReport.array_ind > PdfReport.bc_config_report_lines['FiwalkReport']:
            print("### WARNING ### Feature Report file has exceeded "\
                    "%d lines limit###" \
                    %(PdfReport.bc_config_report_lines['FiwalkReport']))

        self.set_font('Times','',8)
        linenum = 0
        for i in range(0, DirReport.array_ind-1):
            column = 6
            cell_text = DirReport.myDictList[i]['filename']

            # Check if config file is set to not report special files
            if (PdfReport.bc_config_report_special_files == False) \
                and (is_special_file(cell_text)):
                ## print("D: File %s is special. Skipping" %(cell_text))
                continue
 
            # Config file sets the maxlines to 0 to report all the lines
            # or a specific number to limit the reporting lines.
            if (PdfReport.bc_config_report_lines['FiwalkReport'] != 0):
                if (linenum >= PdfReport.bc_config_report_lines['FiwalkReport']):
                    # Lines reached max: Breaking
                    ## print("FiwalkReport: Exceeded Maxlines: ", linenum)
                    break 
                    
            linenum += 1
            
            # Just print the filename if the path exceeds cell width
            if (len(cell_text) > w[0]/2):
                cell_text = filename_from_path(cell_text)
            text = bc_pdf.bc_adjust_text(cell_text, w[0])
            self.cell(w[0],6,text,'LR',0,'L',fill)

            self.cell(w[1],column,DirReport.myDictList[i]['partition'],'LR',0,'L',fill)
            self.cell(w[2],column,DirReport.myDictList[i]['name_type'],'LR',0,'L',fill)
            self.cell(w[3],column,DirReport.myDictList[i]['filesize'],'LR',0,'L',fill)
            if DirReport.myDictList[i]['unalloc']:
                self.cell(w[4],column,'YES','LR',0,'C',fill)
            elif DirReport.myDictList[i]['alloc']:
                self.cell(w[4],column,'NO','LR',0,'C',fill)

            cell_text = str(DirReport.myDictList[i]['libmagic'])
            trimmed_text = bc_pdf.bc_adjust_text(cell_text, w[5])
            self.cell(w[5],column,trimmed_text,'LR',0,'L',fill)
            
            self.ln()
            fill=not fill

            # Start from a new page with header names once
            # reached max_entries allowed per page.
            bc_pdf.bc_table_end_page(self, DirReport, i, header, w)

        # Closure line
        self.cell(sum(w),0,'','T')

#
# This function creates a report file for the feature specified
# by the annotated_file.
#
def create_report_file(input_file, annotated_file):
    # Table column headers
    tab_header_feat = ['Filename', 'Position','Feature ']

    pdf = PDF_BE()
    pdf.compress = False
    pdf.add_page()
    pdf.make_table_feat(input_file,tab_header_feat)

    # Name the pdf file: Remove the first 10 characters: "annotated_"
    # and the last 4 characters: ".txt" and add :.pdf" in the suffix.
    pdf_file = PdfReport.outdir +'/' + annotated_file[10:-3] + 'pdf'
    pdf.output(pdf_file,'F')
    bc_utils.bc_addToReportFileList(pdf_file, PdfReport)
    return(pdf_file)

#
# Class PdfReport: 
#
class PdfReport:
    domain_list_all = []
    domain_list = []
    domain_histo_list = []
    reportFiles = 0
    logo = "FinalBitCuratorLogo-NoText.png" # Default
 
    default_config = False
    bc_config_feature = {}
    bc_config_feature_lines = {}
    bc_config_report_special_files = True
    bc_max_featfiles_to_report = 10
    bc_max_fmtfiles_to_report = 20
    bc_max_lines_to_report = 0
    bc_max_formats_in_bar_graph = 20
    
    # Feature file reports: Two separeate sets are maintained - one for 
    # feature report files (bc_config_feature) and one for all the 
    # rest (bc_config_report_files). The latter is a fixed
    # set, whereas the number of feature report files depends on the bulk-
    # extractor output (and hence the aff image in question).  

    # The elements of bc_config_feature specify a flag to indicate
    # if the user wants to report that feature. Another set, 
    # bc_config_report_lines, lets the user set how many lines of each 
    # feature they want to be idsplayed in the report.

    # The following is a set of all non-feature pdf report files. It is a 
    # growing set. Add more as and when new reports are added.
    bc_config_report_files = {'bc_format_bargraph':0,'FiwalkReport':0, \
                              'FiwalkDeletedFiles':0,'BeReport':0}

    # The following is a corresponding set with the number of lines
    # to be reported in each file, being the value of each element.
    bc_config_report_lines = {'bc_format_bargraph':0,'FiwalkReport':0, \
                              'FiwalkDeletedFiles':0,'BeReport':0}

    def __init__(self, in_dir, out_dir, use_config_file):
 
        import os.path,glob
        self.name = in_dir
        default_config = False

        if os.path.isdir(in_dir):
            self.dname = in_dir
            self.files = set([os.path.basename(x) for x in glob.glob(os.path.join(in_dir,"*.txt"))])

            num_features = len(self.files)
            temp_feature_list = list(self.files)
        else:
            print(">>> File %s doesnot exist" % in_dir) 
            return

        # outdir should not exist. Flag error if it does
        if os.path.exists(out_dir):
            raise RuntimeError(out_dir+" exists")
        if not os.path.exists(out_dir):
            os.mkdir(out_dir)
        

        # Open the Configuration File: If it doesn't exist, default 
        if use_config_file == 'Y' or use_config_file == 'y':
            if (os.path.exists("bc_report_config.txt") == False):
                print("Info: Config file bc_report_config.txt does not exist. Using Default parameters")
                default_config = True
        else:
            # Config file not specified
            ## print(">> Config File not specified. Using defaults")
            default_config = True

        # Initialize the array now that we know the number of elements
        for i in range(0,len(self.files)):
            filename = temp_feature_list[i]

            # ex: annotated_email.txt ==> email
            filename = filename[10:-4]
            self.bc_config_feature[filename] = 0
            self.bc_config_feature_lines[filename] = 0

        if default_config == False:
            #### bc_parse_config_file()
            bc_config.bc_parse_config_file(self)

              
        else:
            # Default config: Report all the feature files and
            # all of the non-feature files     
            report_features = len(temp_feature_list)

            for i in range(0,report_features-1):
                filename = temp_feature_list[i]

                # ex: annotated_email.txt ==> email
                filename = filename[10:-4]
                self.bc_config_feature[filename] = 1

            self.bc_config_report_files['bc_format_bargraph'] = 1
            self.bc_config_report_files['FiwalkReport'] = 1
            self.bc_config_report_files['FiwalkDeletedFiles'] = 1
            self.bc_config_report_files['BeReport'] = 1
                    

        ## print("D: Reporting the following files: ")
        ## print(self.bc_config_feature)
        ## print(self.bc_config_feature_lines)
        ## print(self.bc_config_report_files)
        ## print(self.bc_config_report_lines)

        # Print out a warning if the number of feature files exceeds limit
        if PdfReport.bc_max_featfiles_to_report and \
              num_features > PdfReport.bc_max_featfiles_to_report:
            print("### WARNING ### The number of features exceeds %d ###"
                              %(PdfReport.bc_max_featfiles_to_report)) 

    def open(self,fname,mode='r'):
        print("DEBUG: OPEN= %s " % fname, self);
            
    #
    # Generate feature report files using the per-feature text files
    # generated by bulk-extractor 
    #
    def be_process_generate_report(self, fn, display_option1):
        PdfReport.annotated_dir = fn.annotated_dir
        PdfReport.outdir = fn.outdir

        # Final output will be in pdf form. Text is retained for sometime 
        ofn = fn.outdir + ".txt"

        of = open(ofn,"wb")

        # go through every line of each annotated file, look for 
        # the pattern and write to the report file.
        for annotated_file in self.files:
            input_file = fn.annotated_dir + '/' + annotated_file

            # Look at the config file to see if the user wants a
            # report file. If not, skip to the next feature.
            feature = annotated_file[10:-4]
            if PdfReport.bc_config_feature[feature] == 0:
                ## NOT Reporting this feature 
                continue

            print (">> Creating pdf file for feature", feature)

            ifd = open(input_file, "r")
            linenumber = 0
            of.write(bytes(annotated_file, 'UTF-8')) 
            of.write(b";") 

            for line in ifd:
                linenumber+=1
                if bc_utils.is_comment_line(line):
                    continue # eliminate comments

                bc_utils.match_and_write(of, line, "Total features input", 1)
                bc_utils.match_and_write(of, line, "Total features located to files", 1)
                bc_utils.match_and_write(of, line, "Total features in unallocated space" ,1)
                bc_utils.match_and_write(of, line, "Total features in compressed regions", 0)

                if ((fnmatch.fnmatch(line, 'Total*') or
                    (fnmatch.fnmatch(line, 'Unicode*')))):
                    continue

            # Create a report file for this feature
            pdf_file = create_report_file(input_file, annotated_file)

        of.close()
        return

#
# This function makes a dictionary datastructure of the contents of
# of the input file, which has the file attributes for every file found.
# We will make an array of dictionaries. Each dictionary is a set of the 
# attributes for each file. The List myDictArrayList has the dictionary as 
# each of its element. So it is essentially a 2-dimentional array.
# Number of elements in each dictonary is the number of attributes for each 
# file from the fiwalk output. The number of elements in the big array 
# myDictArrayList is the number of files in the fiwalk output file.
#
def make_dict(linenum, line):
    ##if linenum < 20:
        ##return
    if not line.strip():
        ##print("EMPTY LINE")
        return
    line1 = re.split(":", line)
    if 'md5' in line1[0] or 'sha1' in line1[0]:
        ## print("D:make_dict: SKIPPING MD5 and SHA1: line1:", line1[0])
        return
    if line1[0] in image_fileinfo:
        bc_utils.fw_get_image_info(line1, image_info) 
        return

    # If the line has "filename", it is the beginning of a new array element
    # We will append the previous element to the dictionary. But if this is
    # the very first array element, there is nothing to append. So the flag
    # "is_first_file" is used which is toggeld here to indicate the subsequent
    # one is not the first element.
    #
    if line1[0] in 'filename': #Next sub-array 
        DirReport.array_ind = DirReport.array_ind + 1
        if DirReport.is_first_file==True:
            DirReport.is_first_file = False
        else:
            ## print("D: make_dict: NOT first file anymore is_first_file flag is false ")
            ## for j in range(0, len(DirReport.dict_array)):
                ## print(DirReport.dict_array[j])
            ## print("DEBUG: Last element: ARRAY INDEX NOW IS: ", line1[0], DirReport.array_ind)
            # last element added. Append the array to the dict.
            DirReport.myDictList.append({DirReport.dict_array[0]:DirReport.dict_val[0], \
                         DirReport.dict_array[1]:DirReport.dict_val[1],\
                         DirReport.dict_array[2]:DirReport.dict_val[2],\
                         DirReport.dict_array[3]:DirReport.dict_val[3],\
                         DirReport.dict_array[4]:DirReport.dict_val[4],\
                         DirReport.dict_array[5]:DirReport.dict_val[5],\
                         DirReport.dict_array[6]:DirReport.dict_val[6],\
                         DirReport.dict_array[7]:DirReport.dict_val[7],\
                         DirReport.dict_array[8]:DirReport.dict_val[8],\
                         DirReport.dict_array[9]:DirReport.dict_val[9],\
                         DirReport.dict_array[10]:DirReport.dict_val[10],\
                         DirReport.dict_array[11]:DirReport.dict_val[11],\
                         DirReport.dict_array[12]:DirReport.dict_val[12],\
                         DirReport.dict_array[13]:DirReport.dict_val[13],\
                         DirReport.dict_array[14]:DirReport.dict_val[14],\
                         DirReport.dict_array[15]:DirReport.dict_val[15],\
                         DirReport.dict_array[16]:DirReport.dict_val[16],\
                         DirReport.dict_array[17]:DirReport.dict_val[17],\
                         DirReport.dict_array[18]:DirReport.dict_val[18],\
                         DirReport.dict_array[19]:DirReport.dict_val[19],\
                         DirReport.dict_array[20]:DirReport.dict_val[20],\
                         DirReport.dict_array[21]:DirReport.dict_val[21],\
                         DirReport.dict_array[22]:DirReport.dict_val[22]})

    for ind in range (0, (len(DirReport.dict_array)-1)):
        if line1[0] in DirReport.dict_array[ind]:
            ## print("D: make_dict: Adding line1[0], ind: ", line1[0], line1[1].rstrip(), ind) 
            ## print("D: make_dict: INDEX", DirReport.array_ind, line1[0])

            # Either alloc or unalloc will be present for any file. So set the
            # the value of the other one to 0, for future reference.
            if line1[0] in 'alloc':
                DirReport.dict_val[6] = 0     
            elif line1[0] in 'unalloc':
                DirReport.dict_val[5] = 0     

            DirReport.dict_val[ind] = line1[1].rstrip() 
            break
        
#
# Write the file info to an output file
# Not really needed for pdf report generation, but kept it for debugging 
# purposes
#
def write_file_details(of):
    ## print("D: NUMBER OF ARRAY ELEMENTS: ", DirReport.array_ind)
    of.write(b"Filename \t\t\t part \t id \t dir? \t size \t alc? \t usd? \t meta \t mode \t nlink")
    of.write(bytes("\n=====================================================\n\n", 'UTF-8'))
    for i in range(0, DirReport.array_ind-1):
      #for j in range(0, 21):
        #of.write(bytes(line1[1], 'UTF-8')) 
        of.write(bytes(DirReport.myDictList[i]['filename'], 'UTF-8'))
        of.write(b"\t\t\t")
        of.write(bytes(DirReport.myDictList[i]['partition'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['id'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['name_type'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['filesize'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['alloc'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['used'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['meta_type'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['mode'], 'UTF-8'))
        of.write(b"\t")
        of.write(bytes(DirReport.myDictList[i]['nlink'], 'UTF-8'))
        of.write(b"\n")

#
# This class is used to report information from the output file created 
# by fiwalk program with -T option. 
#
class DirReport:
    index = 0
    from collections import namedtuple
    MyStruct = namedtuple("MyStruct", "filename partition id name_type filesize alloc")
    numfiles = 0
    files = 0
    dirs = 0
    deleted_files = 0
    unused_files = 0
    moreNumlinks = 0
    emptyFiles = 0
    bigFiles = 0
    dict_array = ["filename", "partition", "id", "name_type", "filesize", \
                  "alloc", "unalloc", "used", "inode", "meta_type", "mode", \
                  "nlink", \
                  "uid", "gid", "mtime", "mtime_txt", "ctime", "ctime_txt",\
                  "atime", "atime_txt", "crtime", "crtime_txt", "libmagic", "seq"] 
    dict_val = {}
    myDictList = []
    bcFmtDict = {}
    dictFileFmtVal = {}

    # The file format names are very lengthy and hence using these names
    # as they are from the fiwalk output files makes the barchart look ugly. 
    # But defining a short form for each format gets tough since the formats
    # are ready dynamically. So a static array like the following is maintained 
    # with some known format names mapped to their shorter forms. Those that are
    # not here, will have a short name formed dynamically, with first and last 
    # few characters of the lenghty format name. The purpose of the following
    # static table is to have at least some meaningful names in the bar graph. 
    dictFileFmtStatic = \
         {'empty':'empty','data':'data','none':'none',\
          'AppleDouble encoded Macintosh file':'AppleDouble',\
          'XML document text':'XML',\
          'SQLite 3.x database':'SQLite3x',\
          'Non-ISO extended-ASCII text, with no line terminators':'nISO-EA-NLT',\
          'Non-ISO extended-ASCII text':'nISO-EA',\
          'Hitachi SH big-endian COFF object, not stripped':'Hitachi',\
          'PDP-11 UNIX/RT ldp':'PDP-11',\
          'ISO-8859 text':'ISO-8859',\
          'ISO-8859 text, with no line terminators':'ISO-8859-NLT',\
          'ASCII text':'ASCII',\
          'ASCII text, with no line terminators':'ASCII-NLT',\
          'PDF document, version 1.4':'PDF-1.4',\
          'DOS executable (COM)':'DOSCOM',\
          'ASCII English text, with CRLF line terminators':'ASCII-E-CRLFLT',\
          'ASCII mail text, with CRLF line terminators':'ASCII-mail-CRLFLT', \
          'JPEG image data, JFIF standard 1.01':'JPEG-1.01',\
          'PCX ver. 2.5 image data':'PCX-v2.5-Imagedata',\
          'SysEx File - GreyMatter':'SysEx-GreyMatter',\
          'MS Windows icon resource - 2 icons, 3x, 4-colors':'MSW-2i-3x-4x',\
          'Zip archive data, at least v1.0 to extract':'Ziparc-v1.0',\
          'news or mail, ASCII text, with CRLF line terminators':'newsRmailASCII_CRLFLT' }
    arrayElementNum = 0
    array_ind = 0
    dont_start_yet = True
    is_first_file = True
    page = 0
    max_entries_per_page =30 
    outdir = ''

    def __init__(self,fn):
        import os.path,glob
        self.name = fn
        ## print("D: FN: ", fn)
        if os.path.isfile(fn):
            ## print("D: YES The Fiwalk Txt file EXISTS ", fn)
            self.dname = fn
            self.files = set([os.path.basename(x) for x in glob.glob(os.path.join(fn,"*.txt"))])

            #print("D: FILES: ", self.files)

        # Initialize the values of the dict elements
        for ind in range (0, (len(DirReport.dict_array)-1)):
            DirReport.dict_val[ind] = 0 

    def open(self,fname,mode='r'):
        print("D = %s " % fname);

    # The format string as found in the fiwalk text output is very long.
    # So a shorter name for each format is maintained. It is actually the
    # "value" part of the bcfmtDict structure, which has the "full name" 
    # the dictionary key.
    def bcGetShortNameForFmt(self, fmt_str):
        for x in self.dictFileFmtStatic:
            if fmt_str == x:
                return(self.dictFileFmtStatic[fmt_str])
        else:
            # Not found in the static array. So make up one
            newstr = fmt_str[0:3]+'_'+fmt_str[len(fmt_str) - 3:]
            ## print("Info: Format not found in the Static Array ", fmt_str, newstr) 
            
            ## FIXME: Add it to the static array: Needed to update config info
            return (newstr)

    # The File-format list is maintained dynamically and is populated as
    # a new file-format is read from the main dictionary.
    def bcAddToFmtList(self, fmt_str):
        # Check if the fmt_str is not in the list already
        for x in self.bcFmtDict:
            shortForm = self.bcFmtDict[x]
            if fmt_str == x:
                ## print("D: FOUND fmt:%s, Incrementing Val to %d " \
                ## %(fmt_str,self.dictFileFmtVal[shortForm]))

                # Increment the frequency of this format for the bargraph
                self.dictFileFmtVal[shortForm] += 1
                break
        else:
            # This format is not found in the dict.
            # Look for this format string in the static array to get
            # the short string. If not found, make up one using the first 
            # 3 and last 3 characters. Then add the format to the dict.

            shortFmt = self.bcGetShortNameForFmt(self, fmt_str)

            # Add it to the dictionary.
            self.bcFmtDict[fmt_str] = shortFmt  

            # Set the frequency of this format to 1 for the bargraph
            #self.dictFileFmtVal[fmt_str] = 1
            shortForm = self.bcFmtDict[fmt_str]
            self.dictFileFmtVal[shortForm] = 1

    def process_generate_report_fiwalk(self, fn):
        ## print("DEBUG: ", fn.outdir, fn)
        ofn = fn.outdir + "FI.txt"
        ofn_pdf = fn.outdir + "FI.pdf"

        # Output text file created using bulk-extractor output
        # We will use this text file to populate the pdf report
        ofn_be = fn.outdir + ".txt"
        DirReport.outdir = fn.outdir

        pdf=PDF()
        pdf.compress = False
        pdf.set_font('Arial','B',10)

        of = open(ofn,"wb")
        of.write(b'Directory Structure: \n')
  
        ofn_temp = "temp_file"
        ofn_dict = "dict_file"

        # Open a temp file to write statistics
        of1 = open(ofn_temp,"wb")
        of2 = open(ofn_dict,"wb")
     
        input_file = fn.fiwalk_txtfile
        ifd = open(input_file, "r")
        linenum = 0
        for line in ifd:
            linenum = linenum + 1
            if bc_utils.is_comment_line(line):
                continue # eliminate comments

            # Add the info to the dictionary
            make_dict(linenum, line)

            # First, form the Dictionary of formats found in this fiwalk output file.
            bc_utils.get_file_info(line, DirReport)

        ## bc_utils.print_dict(DirReport) # Just for debugging
        ## print("D: Printing Format Dict for bar-graph: ", self.dictFileFmtVal)

        # Write collected statistics to output file
        # Note:The following code is retained just for testing purpose.
        #of.seek(0,0)
        of1.write(b'Input File Name: ')
        #of.write(str(input_file))
        of1.write(bytes(input_file, 'UTF-8')) 
        of1.write(b'\n\n')
        of1.write(b'\nTotal Files:\t\t')
        of1.write(bytes(str(self.numfiles), 'UTF-8'))
        of1.write(b'\nTotal Directories:\t')
        of1.write(bytes(str(self.dirs), 'UTF-8'))
        of1.write(b'\nTotal Deleted Files:\t')
        of1.write(bytes(str(self.deleted_files), 'UTF-8'))
        of1.write(b'\nTotal Unused Files:\t')
        of1.write(bytes(str(self.unused_files), 'UTF-8'))
        of1.write(b'\nFiles with nliks > 1:\t')
        of1.write(bytes(str(self.moreNumlinks), 'UTF-8'))
        of1.write(b'\nEmpty Files:\t\t')
        of1.write(bytes(str(self.emptyFiles), 'UTF-8'))
        of1.write(b'\nBig Files : \t')
        of1.write(bytes(str(self.bigFiles), 'UTF-8'))
        of1.write(b'\n\n')

        write_file_details(of)

        of.close()
        of1.close()
        of2.close()

        # Table headers
        header_be = ['Bulk Extractor Report Files','Feature Instances','FLTF','FIUF','FICR']
        header_files = ['Filename','Partition','DIR','Size','Deleted','Filetype']
        
        tab_header_delfiles = [' # ', 'Deleted File']
        tab_header_file_fmts = [' # ', 'File']
        tab_header_statistics = ['Feature', 'Value']
        tab_header_bargraph = ['Format', 'Short Form', 'Files']

        # Data for Histogram
        # The frequency of each file-format type is mapped into a histogram/plot.
        # We calculate the number of files in each file format here.

        num_fmt_files = 0
        for x in self.bcFmtDict:
            file_format = x
            short_fmt_name =  self.bcFmtDict[x]
            pdf=PDF()
            pdf.compress = False
            pdf.set_font('Arial','',10)
            pdf.add_page()
            pdf.make_table_fmtfiles(tab_header_file_fmts, file_format)
            pdf_file = fn.outdir + '/format_' + short_fmt_name + '.pdf'
                
            pdf.output(pdf_file,'F')
            bc_utils.bc_addToReportFileList(pdf_file, PdfReport)
          
            num_fmt_files += 1

            # if the configured value for nax fmtfiles is 0, it reports all.
            # else it uses the number specified in the config file.
            # If the number not configured, it uses the hardcoded default:20
            if  PdfReport.bc_max_fmtfiles_to_report and \
                 num_fmt_files >= PdfReport.bc_max_fmtfiles_to_report:
                ## print("D: FMT files exceeded max limit of %d" %(num_fmt_files))
                break
                              
        ## Report the bargraph only if the configuration file says so
        outfile = DirReport.outdir + '/bc_format_bargraph.pdf'
        if PdfReport.bc_config_report_files['bc_format_bargraph']:
            bc_graph.bc_draw_histogram_fileformat(PdfReport, image_info, \
                                                  outfile, self.dictFileFmtVal)

            # Also make a table of the same information
            pdf=PDF()
            pdf.compress = False
            pdf.set_font('Arial','',10)
            pdf.add_page()
            pdf.bc_make_table_fileformat(tab_header_bargraph, self.dictFileFmtVal, self.bcFmtDict)
            pdf_file = fn.outdir + '/format_table.pdf'
            pdf.output(pdf_file,'F')
            bc_utils.bc_addToReportFileList(pdf_file, PdfReport)


        ## Report the Fiwalk Report file only if the config file says so
        if PdfReport.bc_config_report_files['FiwalkReport'] == 1:
            pdf=PDF()
            pdf.compress = False
            pdf.set_title("Bitcurator Report")
 
            # Print the statistics first
            pdf.set_font('Arial','',10)
            pdf.add_page()
            pdf.make_table_stat(tab_header_statistics)

            pdf.set_font('Arial','',10)
            pdf.add_page()
            pdf.make_table(header_files)
            pdf_file = fn.outdir + '/FiwalkReport.pdf'
            pdf.output(pdf_file,'F')
            bc_utils.bc_addToReportFileList(pdf_file, PdfReport)
        
        # Generate the Report of deleted files

        ## Report the Deleted Files only if the config file says so
        if PdfReport.bc_config_report_files['FiwalkDeletedFiles'] == 1:
            ## print("D: Generating Deleted Files Report")
            pdf=PDF()
            pdf.compress = False
            pdf.set_font('Arial','B',10)
            pdf.add_page()
            y = pdf.get_y()
            pdf.set_y(y+10)
            pdf.make_table_delfiles(tab_header_delfiles)
            pdf_file = fn.outdir + '/FiwalkDeletedFiles.pdf'
            pdf.output(pdf_file, 'F')
            bc_utils.bc_addToReportFileList(pdf_file, PdfReport)

        ## Now add the info from bulk-extractor output (be_ofn)
        ## Report the BE Report file only if the config file says so
        if PdfReport.bc_config_report_files['BeReport'] == 1:
            pdf=PDF_BE()
            pdf.compress = False

            pdf.set_font('Arial','B',10)
            pdf.add_page()
            y = pdf.get_y()
            pdf.set_y(y+10)
            pdf.set_text_color(128)
            pdf.make_table_be(header_be, ofn_be)

            pdf_file = fn.outdir + '/BeReport.pdf'
            pdf.output(pdf_file,'F')
            bc_utils.bc_addToReportFileList(pdf_file, PdfReport)

        ## print("Printing the Generated PDF files ")
        bc_utils.bc_printReportFileList(PdfReport)

if __name__=="__main__":
    import sys, time, re

    parser = ArgumentParser(prog='generate_report.py', description='Generate Reports from "bulk_extractor" and "fiwalk" outputs')
    parser.add_argument('--pdf_report', action='store_true',help='PDF report')
    parser.add_argument('--fiwalk_txtfile', action='store', help="Use fiwalk-generated text file ")
    parser.add_argument('--annotated_dir', action='store', help="Directory containing annotated files ")
    parser.add_argument('--outdir',action='store',help='Output directory; must not exist')
    
    args = parser.parse_args()

    ## print("D: PDF REPORT", args.pdf_report)
    ## print("D: FIWALK_TXTFILE", args.fiwalk_txtfile)
    ## print("D: Annotated_DIR", args.annotated_dir)
    ## print("D: OUTDIR", args.outdir)

    config_file = "bc_report_config.txt"
    if args.pdf_report:

        use_config_file = (input (">>> Do you want to specify the configuration file?: [Y/N]:"))

        if use_config_file == 'Y' or use_config_file == 'y':
            config_file = (input (">>> Please specify the configuration file[bc_report_config.txt]: "))

            # If hit return, use the default: bc_report_config.txt.
            # In either case, see if the file exists.
            if (config_file == ''):
                # User pressed return. Use the default file: bc_report_config.txt
                config_file = "bc_report_config.txt"

            if not os.path.exists(config_file):
                print(">>> Configuration file %s does not exist. Using default values" %(config_file))
                use_config_file = "N"
                
        elif use_config_file == 'N' or use_config_file == 'n':
            print(">>> You have opted to select the default values for reporting")
        else:
            print(">>> Wrong option. Defaulting")
            use_config_file = 'N'

        report = PdfReport(args.annotated_dir, args.outdir, use_config_file)
        report.be_process_generate_report(args, use_config_file)

        # Using the xml file generated by fiwalk, report the following
        # information:

        fiwalk_txtfile = None
        if args.fiwalk_txtfile:
            fiwalk_txtfile = args.fiwalk_txtfile

            ## print("D: Using Fiwalk TXT file ", fiwalk_txtfile)

            report_fi = DirReport(args.fiwalk_txtfile)
            report_fi.process_generate_report_fiwalk(args)
        exit(1)
    

    
