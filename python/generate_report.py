#!/usr/bin/python
# coding=UTF-8
# 
'''
File: bc_generate_report.py
A module for working with bulk_extractor

This module works with bulk_extractor and identify_filenames moduels
and extracts the annotaed files  generated by the identify_filenames
module and generates a report.

'''

__version__ = "1.3.0"

b'This module needs Python 2.7 or later.'
import zipfile,os,os.path,glob,codecs
##from pyfpdf import FPDF
###import fpdf
import re
import os
import fnmatch
from collections import namedtuple

def is_comment_line(line):
    if len(line)==0: return False
    if line[0:4]==b'\xef\xbb\xbf#': return True
    if line[0:1]=='\ufeff':
        line=line[1:]       # ignore unicode BOM
    try:
        if ord(line[0])==65279:
            line=line[1:]       # ignore unicode BOM
    except TypeError:
        pass
    if line[0:1]==b'#' or line[0:1]=='#':
        return True
    return False

def match_and_write(of, line, pattern):
    if re.match(pattern,line):
        line1 = re.split(":", line.rstrip('\n'))
        #print("DEBUG: LINE1: ", line1, line1[1])
        of.write(bytes(line1[1], 'UTF-8')) 
        of.write(b"\t") 

def bc_analyze_zip_file(of, line):
    #line1 = re.split(" ", line.rstrip('\n'))
    #line1 = line.split()
    line1 = line.split("\t")
    ##for i  in range(0, len(line1)):
        ##print("DEBUGGGGGGG:", line1[i])
    #print("DEBUGGGGGGG:", line1[1])
        #print("DEBUGGGGGGG:", line1[3])
        #print("DEBUGGGGGGG:", line1[4])

def bc_update_histo_list(list_item):
    # Walk through the list looking for the list_item.
    # If not found, add an item each to domain_list and histo_list.
    # These two lists have equal number of elements and each index
    # in the former has a corresponding number (number of occurances)
    # in the domain_histo_list. If the element is found in the big list 
    # (domain_list_all), then increment the corresponding histo_list

    print("ADDING LIST ITEM: ", list_item)
    ##for i in range(0, len(PdfReport.domain_list_all)):
    if (len(PdfReport.domain_list) == 0):
        print("FIRST ITEM: Appending list_item to domain_list ", list_item)
        PdfReport.domain_list.append(list_item)
        PdfReport.domain_histo_list.append(1)
        return

    for j in range(0, len(PdfReport.domain_list)):
        print(" dl[] = ", j, PdfReport.domain_list[j], list_item) 
        if (PdfReport.domain_list[j] == list_item):
            # item exists in the domain_list. Increment
            # corresponding element in histo_list
            print(" They are the same. So imcrementing h-list ")
            PdfReport.domain_histo_list[j] += 1
            break

    else:
        #print(" dl[NOW] = ", j, PdfReport.domain_list[j], list_item) 
        if (PdfReport.domain_list[j] != list_item):
            # Done traversing the domain_list. Add the new element
            # to both the domain and histogram lists.
            print("Appending list_item to domain_list ", list_item)
            PdfReport.domain_list.append(list_item)
            PdfReport.domain_histo_list.append(1)
            
    print("domain_list", PdfReport.domain_list)
    print("domain__histo_list", PdfReport.domain_histo_list)
    ##for k in range(0, len(PdfReport.domain_list)):
        ##of.write(bytes(PdfReport.domain_list_all[k], 'UTF-8')) 
        ##print(PdfReport.domain_list[k]) 
        ##print(PdfReport.domain_histo_list[k]) 
            

def bc_analyze_domain_file(of, line):

    line1 = line.split("\t")
    #print("STATICVAR : %d ", PdfReport.static_var)


    # Populate the array
    ##print("Appending to ALL file: ", line1[1])
    PdfReport.domain_list_all.append(line1[1])
    bc_update_histo_list(line1[1])

'''
        #of.write(bytes(PdfReport.domain_list_all, 'UTF-8')) 
        ## The following writes all the domains - kept just
        ## to test. Remove before cleanup.
        ##for j in range(0, len(PdfReport.domain_list_all)):
        ##of.write(bytes(PdfReport.domain_list_all[j], 'UTF-8')) 
'''

def bc_analyze_lines(of, line, input_file):
    #if (input_file in "annotated_zip.txt"):
    if (fnmatch.fnmatch(input_file, '*annotated_zip.txt')):
        #print ("Analyzing ZIP file")
        bc_analyze_zip_file(of, line)
    elif (fnmatch.fnmatch(input_file, '*annotated_domain.txt')):
        ##print ("Analyzing DOMAIN file")
        bc_analyze_domain_file(of, line)

def bc_write_histo_outfile(of):

    of.write(b"\n\n")
    of.write(b"Domain ")
    of.write(b"\t\t\t ") 
    of.write(b"Frequency")
    of.write(b"\n")

    print("\n\n")
    print("Domain \t\t\t Frequency") 
    print("\n")
    print("LRN: ", len(PdfReport.domain_list))
    for k in range (0, len(PdfReport.domain_list)): 
        print(PdfReport.domain_list[k], 
                          PdfReport.domain_histo_list[k])
        ##print("\t\t\t") 
        ##print(PdfReport.domain_histo_list[k])
        of.write(bytes(PdfReport.domain_list[k], 'UTF-8'))
        #of.write(bytes(PdfReport.domain_list[k], 'UTF-8'))
        of.write(b"\t\t\t") 
        #of.write(bytes(PdfReport.domain_histo_list[k], 'UTF-8'))
        ### The following works but writes garbage
        of.write(bytes(str(PdfReport.domain_histo_list[k]), 'UTF-8'))
        #of.write(bytes(PdfReport.domain_histo_list[k], 'UTF-8'))
        of.write(b"\n")

class PdfReport:
    #static_var = 99
    domain_list_all = []
    domain_list = []
    domain_histo_list = []
    def __init__(self,fn):
 
        import os.path,glob
        self.name = fn
        if os.path.isdir(fn):
            #print("DEBUG: YES IT IS A DIR ", fn)
            self.dname = fn
            self.files = set([os.path.basename(x) for x in glob.glob(os.path.join(fn,"*.txt"))])

            #print("DEBUG: FILES: ", self.files)

    def open(self,fname,mode='r'):
        print("DEBUG: OPEN= %s " % fname, self);


    def process_generate_report(self, fn):
        #print("DEBUG: ", fn.outdir, fn)

        # Final output will be in pdf form. Till it is implemented
        # it will be reported in txt form.
        #ofn = fn.outdir + ".pdf"
        ofn = fn.outdir + ".txt"

        #print("DEBUG: OFN: ", ofn)
        if os.path.exists(ofn):
            # Sunitha: Find out how to remove the file instead of 
            # annoying the user.
            raise RuntimeError(ofn+" exists")

        of = open(ofn,"wb")
        of.write(b'PDF REPORT of IMAGE: \n')
        of.write(b'FLTF:Total features located to files \n')
        of.write(b'FIUF:Total features in unallocated to files \n')
        of.write(b'FICR:Total features in compressed regions \n')
        of.write(b'# File-name\t\tNum Entries\tFLTF\tFIUF\tFICR\n')

        # go through every line of each annotated file, look for 
        # the pattern and write to the report file.
        for annotated_file in self.files:
            input_file = fn.outdir + '/' + annotated_file
            print("file: ", input_file)
            #of.write(annoteated_file) 
            ifd = open(input_file, "r")
            linenumber = 0
            of.write(b"\n") 
            of.write(bytes(annotated_file, 'UTF-8')) 
            of.write(b"\t\t") 
            for line in ifd:
                linenumber+=1
                #print ("LINE: ", line)
                if is_comment_line(line):
                    print("Comment Line: linenum: ", linenumber)
                    continue # eliminate comments
                match_and_write(of, line, "Total features input")
                match_and_write(of, line, "Total features located to files")
                match_and_write(of, line, "Total features in unallocated space")
                match_and_write(of, line, "Total features in compressed regions")

                if ((fnmatch.fnmatch(line, 'Total*') or
                    (fnmatch.fnmatch(line, 'Unicode*')))):
                    print("REACHED LAST LINES ")
                    break
                else:
                    bc_analyze_lines(of, line, input_file)

        bc_write_histo_outfile(of)

        of.close()
        return


        ##pdf=FPDF()
        ##pdf.add_page()
        ##pdf.set_font('Arial','B',16)
        ##pdf.cell(40,10,'Hello World!')


